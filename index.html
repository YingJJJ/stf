<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–‡æœ¬æ ¼å¼åŒ–å·¥å…·</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <!-- SweetAlert2 -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Microsoft YaHei', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
        }
        
        .main-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            margin: 2rem auto;
            max-width: 1200px;
        }
        
        .header-section {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border-radius: 20px 20px 0 0;
            padding: 2rem;
            text-align: center;
        }
        
        .header-section h1 {
            margin: 0;
            font-weight: 300;
            font-size: 2.5rem;
        }
        
        .header-section p {
            margin: 0.5rem 0 0 0;
            opacity: 0.9;
        }
        
        .content-section {
            padding: 2rem;
        }
        
        .card {
            border: none;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            margin-bottom: 1.5rem;
        }
        
        .card-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px 15px 0 0 !important;
            border: none;
            padding: 1rem 1.5rem;
        }
        
        .form-label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 0.5rem;
        }
        
        .form-control, .form-select {
            border-radius: 10px;
            border: 1px solid #e3e6f0;
            padding: 0.75rem 1rem;
            transition: all 0.3s ease;
        }
        
        .form-control:focus, .form-select:focus {
            border-color: #4facfe;
            box-shadow: 0 0 0 0.2rem rgba(79, 172, 254, 0.25);
        }
        
        .btn {
            border-radius: 10px;
            padding: 0.75rem 1.5rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border: none;
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #00f2fe 0%, #4facfe 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            border: none;
        }
        
        .btn-success:hover {
            background: linear-gradient(135deg, #38ef7d 0%, #11998e 100%);
            transform: translateY(-2px);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
            border: none;
        }
        
        .btn-info {
            background: linear-gradient(135deg, #ff9a56 0%, #ff6b35 100%);
            border: none;
        }
        
        .btn-info:hover {
            background: linear-gradient(135deg, #ff6b35 0%, #ff9a56 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
        }
        
        .result-area {
            white-space: pre;
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 10px;
            min-height: 200px;
            overflow-x: auto;
            overflow-y: auto;
            font-family: 'Courier New', 'Monaco', monospace;
            border: 1px solid #e3e6f0;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .icon-text {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .feature-badge {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            color: #8b4513;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .custom-textarea {
            height: 180px;
            resize: vertical;
        }
        
        @media (max-width: 768px) {
            .main-container {
                margin: 1rem;
                border-radius: 15px;
            }
            
            .header-section {
                padding: 1.5rem 1rem;
                border-radius: 15px 15px 0 0;
            }
            
            .header-section h1 {
                font-size: 2rem;
            }
            
            .content-section {
                padding: 1.5rem 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- å¤´éƒ¨åŒºåŸŸ -->
        <div class="header-section">
            <h1><i class="bi bi-textarea-t"></i> æ™ºèƒ½æ–‡æœ¬æ ¼å¼åŒ–å·¥å…·</h1>
            <p>æ”¯æŒå¤šç§åˆ†æ®µæ¨¡å¼çš„ä¸“ä¸šæ–‡æœ¬å¤„ç†å·¥å…·</p>
        </div>
        
        <!-- å†…å®¹åŒºåŸŸ -->
        <div class="content-section">
            <!-- è¾“å…¥æ–‡æœ¬å¡ç‰‡ -->
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <span class="icon-text">
                            <i class="bi bi-pencil-square"></i>
                            æ–‡æœ¬è¾“å…¥
                        </span>
                    </h5>
                </div>
                <div class="card-body">
                    <label for="input-text" class="form-label">è¾“å…¥éœ€è¦æ ¼å¼åŒ–çš„æ–‡æœ¬:</label>
                    <textarea id="input-text" class="form-control custom-textarea" placeholder="è¯·åœ¨æ­¤è¾“å…¥é•¿æ–‡æœ¬..."></textarea>
                </div>
            </div>
            
            <!-- æ ¼å¼åŒ–è®¾ç½®å¡ç‰‡ -->
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <span class="icon-text">
                            <i class="bi bi-gear"></i>
                            æ ¼å¼åŒ–è®¾ç½®
                            <span class="feature-badge">æ¨èæŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µ</span>
                        </span>
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row g-3">
                        <div class="col-md-6">
                            <label for="format-mode" class="form-label">
                                <i class="bi bi-list-ul text-primary"></i> åˆ†æ®µæ¨¡å¼:
                            </label>
                            <select id="format-mode" class="form-select">
                                <option value="char">æŒ‰å­—ç¬¦åˆ†æ®µ</option>
                                <option value="word">æŒ‰å•è¯åˆ†æ®µ</option>
                                <option value="sentence">æŒ‰å¥å­åˆ†æ®µ</option>
                                <option value="punctuation" selected>â­ æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µ (æ¨è)</option>
                                <option value="word_and_punctuation">æŒ‰å•è¯å’Œæ ‡ç‚¹ç¬¦å·åˆ†æ®µ</option>
                                <option value="natural">è‡ªç„¶è¯­è¨€åˆ†æ®µ</option>
                            </select>
                        </div>
                        
                        <div class="col-md-6">
                            <label for="max-width" class="form-label">
                                <i class="bi bi-arrows-expand text-success"></i> æ¯è¡Œæœ€å¤§å®½åº¦:
                            </label>
                            <input type="number" id="max-width" class="form-control" value="69" min="10" max="2000">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- æ›¿æ¢åŠŸèƒ½å¡ç‰‡ -->
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <span class="icon-text">
                            <i class="bi bi-arrow-left-right"></i>
                            æ–‡æœ¬æ›¿æ¢ (å¯é€‰)
                        </span>
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row g-3">
                        <div class="col-md-4">
                            <label for="find-text" class="form-label">æŸ¥æ‰¾:</label>
                            <input type="text" id="find-text" class="form-control" placeholder="è¾“å…¥è¦æ›¿æ¢çš„æ–‡æœ¬">
                        </div>
                        
                        <div class="col-md-4">
                            <label for="replace-text" class="form-label">æ›¿æ¢ä¸º:</label>
                            <input type="text" id="replace-text" class="form-control" placeholder="è¾“å…¥æ›¿æ¢åçš„æ–‡æœ¬">
                        </div>
                        
                        <div class="col-md-4 d-flex align-items-end">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="enable-replace">
                                <label class="form-check-label" for="enable-replace">
                                    å¯ç”¨æ›¿æ¢åŠŸèƒ½
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- è‡ªå®šä¹‰æ–­å¥å¡ç‰‡ -->
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <span class="icon-text">
                            <i class="bi bi-scissors"></i>
                            è‡ªå®šä¹‰æ–­å¥ (é«˜çº§)
                        </span>
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row g-3">
                        <div class="col-md-9">
                            <label for="custom-break-words" class="form-label">è‡ªå®šä¹‰æ–­å¥è¯ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰:</label>
                            <input type="text" id="custom-break-words" class="form-control" placeholder="è¾“å…¥è¦ä½œä¸ºæ–­å¥ç‚¹çš„å•è¯æˆ–çŸ­è¯­ï¼Œå¦‚: ä¾‹å¦‚,æ¯”å¦‚,ä¾‹å­">
                            <div class="form-text">
                                <i class="bi bi-info-circle text-primary"></i>
                                æ­¤åŠŸèƒ½åœ¨"æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µ"ã€"æŒ‰å•è¯å’Œæ ‡ç‚¹ç¬¦å·åˆ†æ®µ"å’Œ"è‡ªç„¶è¯­è¨€åˆ†æ®µ"æ¨¡å¼ä¸‹æœ‰æ•ˆ
                            </div>
                            <div class="d-flex gap-2 mt-2">
                                <button id="save-break-words" class="btn btn-success btn-sm flex-fill">
                                    <i class="bi bi-save"></i> ä¿å­˜æ–­å¥è¯
                                </button>
                                <button id="clear-break-words" class="btn btn-danger btn-sm flex-fill">
                                    <i class="bi bi-trash"></i> æ¸…é™¤æ–­å¥è¯
                                </button>
                            </div>
                        </div>
                        
                        <div class="col-md-3 d-flex align-items-end">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="enable-custom-break" checked>
                                <label class="form-check-label" for="enable-custom-break">
                                    å¯ç”¨è‡ªå®šä¹‰æ–­å¥
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- æ“ä½œæŒ‰é’® -->
            <div class="text-center mb-4">
                <button id="format-btn" class="btn btn-primary btn-lg">
                    <i class="bi bi-play-circle"></i> æ ¼å¼åŒ–æ–‡æœ¬
                </button>
            </div>
            
            <!-- ç»“æœè¾“å‡ºå¡ç‰‡ -->
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">
                        <span class="icon-text">
                            <i class="bi bi-file-text"></i>
                            æ ¼å¼åŒ–ç»“æœ
                        </span>
                    </h5>
                    <button id="copy-btn" class="btn btn-info btn-sm">
                        <i class="bi bi-clipboard"></i> å¤åˆ¶æ–‡æœ¬
                    </button>
                </div>
                <div class="card-body">
                    <div id="output-text" class="result-area"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- é¡µè„š -->
    <footer class="text-center py-4">
        <div class="container">
            <p class="mb-0 text-light">
                <i class="bi bi-heart-fill text-danger"></i>
                æ–‡æœ¬æ ¼å¼åŒ–å·¥å…· &copy; 2025 - è®©æ–‡æœ¬å¤„ç†æ›´ç®€å•
            </p>
        </div>
         </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // æ˜¾ç¤ºæ¬¢è¿å¼¹çª—
            Swal.fire({
                title: 'ğŸ‰ æ¬¢è¿ä½¿ç”¨æ–‡æœ¬æ ¼å¼åŒ–å·¥å…·',
                html: `
                    <div style="text-align: left; line-height: 1.6;">
                        <p style="text-align: center; color: #2196F3; font-size: 18px; margin-bottom: 20px;">
                            ğŸ’¡ æ¨èä½¿ç”¨ <strong style="color: #e74c3c;">æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µ</strong> æ¨¡å¼ï¼Œå…¶å®ƒæ¨¡å¼å¯èƒ½å­˜åœ¨æœªçŸ¥é—®é¢˜
                        </p>
                        <div style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <h4 style="color: #333; margin-bottom: 10px;">ğŸ“‹ æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µé€»è¾‘ï¼š</h4>
                            <ol style="margin: 0; padding-left: 20px;">
                                <li style="margin-bottom: 8px;"><strong>ç¬¬ä¸€æ­¥ï¼š</strong>å…ˆæŒ‰æ ‡ç‚¹ç¬¦å·æ–­å¥ï¼ˆåº•å±‚é€»è¾‘ï¼Œä¼˜å…ˆçº§æœ€é«˜ï¼‰</li>
                                <li style="margin-bottom: 8px;"><strong>ç¬¬äºŒæ­¥ï¼š</strong>æ ¹æ®è‡ªå®šä¹‰å•è¯æ–­å¥ï¼ˆåªæ–­è¶…è¿‡å­—ç¬¦é™åˆ¶çš„å¥å­ï¼‰</li>
                                <li style="margin-bottom: 8px;"><strong>ç¬¬ä¸‰æ­¥ï¼š</strong>å¦‚æœæ— è‡ªå®šä¹‰å•è¯ï¼Œåˆ™å–ä¸­ä½æ•°æ–­å¥</li>
                            </ol>
                        </div>
                        <p style="text-align: center; color: #666; font-size: 14px;">
                            ğŸ’¡ è¿™ç§åˆ†æ®µæ–¹å¼èƒ½ä¿æŒæ–‡æœ¬çš„é€»è¾‘å®Œæ•´æ€§ï¼ŒåŒæ—¶æä¾›çµæ´»çš„è‡ªå®šä¹‰é€‰é¡¹
                        </p>
                    </div>
                `,
                icon: 'info',
                confirmButtonText: 'å¼€å§‹ä½¿ç”¨',
                confirmButtonColor: '#4CAF50',
                width: '600px',
                backdrop: true,
                allowOutsideClick: false
            });
            
            // è·å–DOMå…ƒç´ 
            const inputText = document.getElementById('input-text');
            const formatMode = document.getElementById('format-mode');
            const maxWidth = document.getElementById('max-width');
            const formatBtn = document.getElementById('format-btn');
            const outputText = document.getElementById('output-text');
            const customBreakWordsInput = document.getElementById('custom-break-words');
            const saveBreakWordsBtn = document.getElementById('save-break-words');
            const clearBreakWordsBtn = document.getElementById('clear-break-words');
            const copyBtn = document.getElementById('copy-btn');
            
            // åŠ è½½ä¿å­˜çš„æ–­å¥è¯
            if (localStorage.getItem('customBreakWords')) {
                customBreakWordsInput.value = localStorage.getItem('customBreakWords');
            }
            
            // ä¿å­˜æ–­å¥è¯äº‹ä»¶
            saveBreakWordsBtn.addEventListener('click', function() {
                const breakWords = customBreakWordsInput.value.trim();
                if (breakWords) {
                    localStorage.setItem('customBreakWords', breakWords);
                    alert('æ–­å¥è¯å·²ä¿å­˜ï¼');
                } else {
                    alert('è¯·å…ˆè¾“å…¥æ–­å¥è¯å†ä¿å­˜');
                }
            });
            
            // æ¸…é™¤æ–­å¥è¯äº‹ä»¶
            clearBreakWordsBtn.addEventListener('click', function() {
                if (confirm('ç¡®å®šè¦æ¸…é™¤ä¿å­˜çš„æ–­å¥è¯å—ï¼Ÿ')) {
                    localStorage.removeItem('customBreakWords');
                    customBreakWordsInput.value = '';
                    alert('æ–­å¥è¯å·²æ¸…é™¤ï¼');
                }
            });
            
            // å¤åˆ¶åŠŸèƒ½äº‹ä»¶
            copyBtn.addEventListener('click', async function() {
                const textToCopy = outputText.textContent;
                
                if (!textToCopy || !textToCopy.trim()) {
                    alert('æ²¡æœ‰å†…å®¹å¯ä»¥å¤åˆ¶ï¼Œè¯·å…ˆæ ¼å¼åŒ–æ–‡æœ¬ï¼');
                    return;
                }
                
                try {
                    // ä½¿ç”¨ç°ä»£ Clipboard API
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(textToCopy);
                        // ä¸´æ—¶æ”¹å˜æŒ‰é’®æ–‡å­—å’Œé¢œè‰²æä¾›åé¦ˆ
                        const originalText = copyBtn.textContent;
                        const originalColor = copyBtn.style.backgroundColor;
                        copyBtn.textContent = 'å¤åˆ¶æˆåŠŸï¼';
                        copyBtn.style.backgroundColor = '#4CAF50';
                        
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.style.backgroundColor = originalColor;
                        }, 2000);
                    } else {
                        // é™çº§åˆ°ä¼ ç»Ÿæ–¹æ³•
                        const textArea = document.createElement('textarea');
                        textArea.value = textToCopy;
                        textArea.style.position = 'fixed';
                        textArea.style.left = '-999999px';
                        textArea.style.top = '-999999px';
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        
                        if (document.execCommand('copy')) {
                            // ä¸´æ—¶æ”¹å˜æŒ‰é’®æ–‡å­—å’Œé¢œè‰²æä¾›åé¦ˆ
                            const originalText = copyBtn.textContent;
                            const originalColor = copyBtn.style.backgroundColor;
                            copyBtn.textContent = 'å¤åˆ¶æˆåŠŸï¼';
                            copyBtn.style.backgroundColor = '#4CAF50';
                            
                            setTimeout(() => {
                                copyBtn.textContent = originalText;
                                copyBtn.style.backgroundColor = originalColor;
                            }, 2000);
                        } else {
                            alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬è¿›è¡Œå¤åˆ¶');
                        }
                        
                        document.body.removeChild(textArea);
                    }
                } catch (error) {
                    console.error('å¤åˆ¶å¤±è´¥:', error);
                    alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬è¿›è¡Œå¤åˆ¶');
                }
            });
            
            // æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            formatBtn.addEventListener('click', function() {
                try {
                    const text = inputText.value;
                    const mode = formatMode.value;
                    const width = parseInt(maxWidth.value);
                    
                    if (!text.trim()) {
                        outputText.textContent = "è¯·è¾“å…¥è¦æ ¼å¼åŒ–çš„æ–‡æœ¬";
                        return;
                    }
                    
                    // å…ˆæ‰§è¡Œæ›¿æ¢
                    let processedText = text;
                    const enableReplace = document.getElementById('enable-replace').checked;
                    const findText = document.getElementById('find-text').value;
                    const replaceText = document.getElementById('replace-text').value;
                    
                    if (enableReplace && findText) {
                        // åˆ›å»ºå…¨å±€æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œæ›¿æ¢
                        const regex = new RegExp(findText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                        processedText = processedText.replace(regex, replaceText);
                    }
                    
                    // è·å–è‡ªå®šä¹‰æ–­å¥è¯
                    const enableCustomBreak = document.getElementById('enable-custom-break').checked;
                    const customBreakWords = enableCustomBreak && customBreakWordsInput.value.trim() ? 
                        customBreakWordsInput.value.split(',').map(word => word.trim()).filter(word => word) : 
                        [];
                    
                    // æ ¼å¼åŒ–æ–‡æœ¬
                    const result = formatText(processedText, width, mode, customBreakWords);
                    outputText.textContent = result;
                } catch (error) {
                    console.error('æ ¼å¼åŒ–æ–‡æœ¬æ—¶å‘ç”Ÿé”™è¯¯:', error);
                    outputText.textContent = "æ ¼å¼åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¾“å…¥å†…å®¹æˆ–åˆ·æ–°é¡µé¢é‡è¯•";
                }
            });
            
            // æ ¼å¼åŒ–å‡½æ•°
            function formatText(text, maxWidth = 80, mode = 'char', customBreakWords = []) {
                // é¢„å¤„ç†ï¼šå°†å¼•å·å†…çš„å†…å®¹ä¿æŠ¤èµ·æ¥ï¼ˆquotesæ¨¡å¼é™¤å¤–ï¼‰
                const quotedTexts = [];
                let processedText = text;
                
                // åªæœ‰åœ¨équotesæ¨¡å¼ä¸‹æ‰é¢„å¤„ç†å¼•å·å†…å®¹
                if (mode !== 'quotes') {
                    processedText = text.replace(/"([^"]*)"/g, function(match, content) {
                        // å°†å¼•å·å†…å®¹æ›¿æ¢ä¸ºç‰¹æ®Šæ ‡è®°
                        const placeholder = `__QUOTED_TEXT_${quotedTexts.length}__`;
                        quotedTexts.push(content);
                        return placeholder;
                    });
                }
                
                let result;
                
                if (mode === 'char') {
                    // æŒ‰å­—ç¬¦æ•°åˆ†æ®µ
                    const resultArray = [];
                    for (let i = 0; i < processedText.length; i += maxWidth) {
                        resultArray.push(processedText.substring(i, i + maxWidth));
                    }
                    result = resultArray.join('\n');
                    
                } else if (mode === 'word') {
                    // æŒ‰å•è¯åˆ†æ®µï¼Œé¿å…å•è¯è¢«æˆªæ–­
                    const words = processedText.split(/\s+/);
                    const lines = [];
                    let currentLine = [];
                    let currentLength = 0;
                    
                    for (const word of words) {
                        const wordLength = word.length;
                        const spaceLength = currentLength > 0 ? 1 : 0;
                        
                        if (currentLength + wordLength + spaceLength <= maxWidth) {
                            currentLine.push(word);
                            currentLength += wordLength + spaceLength;
                        } else {
                            lines.push(currentLine.join(' '));
                            currentLine = [word];
                            currentLength = wordLength;
                        }
                    }
                    
                    if (currentLine.length > 0) {
                        lines.push(currentLine.join(' '));
                    }
                    
                    result = lines.join('\n');
                    
                } else if (mode === 'sentence') {
                    // æŒ‰å¥å­åˆ†æ®µ
                    // ä¿®å¤ï¼šåŒæ—¶åŒ¹é…ä¸­è‹±æ–‡å¥å·ã€é—®å·ã€æ„Ÿå¹å·ï¼Œä¸”å…è®¸æ„Ÿå¹å·åæ— ç©ºæ ¼çš„æƒ…å†µ
                    const sentences = processedText.split(/(?<=[.!?ã€‚ï¼ï¼Ÿ])\s*(?=\S|$)/);
                    result = sentences.join('\n');
                    
                } else if (mode === 'punctuation') {
                    // æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µ - é‡å†™é€»è¾‘ï¼šæ ‡ç‚¹ç¬¦å· â†’ è‡ªå®šä¹‰æ–­å¥ â†’ ä¸­ä½æ•°åˆ†æ®µ
                    
                    // ç¬¬1æ­¥ï¼šæŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µï¼ˆåº•å±‚é€»è¾‘ï¼Œä¼˜å…ˆçº§æœ€é«˜ï¼‰
                    // å®Œå…¨æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µï¼Œä¸è€ƒè™‘æœ€å¤§å®½åº¦é™åˆ¶
                    // åŒ¹é…ä¸­è‹±æ–‡å„ç§æ ‡ç‚¹ç¬¦å·ï¼Œä½†æ’é™¤è¯ä¸­çš„æ’‡å·å’Œå¼•å·
                    let punctuationSegments = processedText.split(/([,.;:!?ï¼Œã€‚ï¼›ï¼šï¼ï¼Ÿã€ï¼ˆï¼‰ã€Šã€‹ã€ã€‘]|(?<!\w)'(?!\w)|(?<!\w)'(?!\w))/);
                    
                    // æ¸…ç†å’Œé‡ç»„åˆ†æ®µï¼Œå°†æ ‡ç‚¹ç¬¦å·ä¸å‰é¢çš„æ–‡æœ¬åˆå¹¶
                    const punctuationBasedSegments = [];
                    let currentSegment = '';
                    
                    for (let i = 0; i < punctuationSegments.length; i++) {
                        const part = punctuationSegments[i];
                        
                        if (!part) continue; // è·³è¿‡ç©ºå­—ç¬¦ä¸²
                        
                        // å¦‚æœæ˜¯æ ‡ç‚¹ç¬¦å·ï¼Œä¸å‰é¢çš„å†…å®¹åˆå¹¶
                        if (/^[,.;:!?ï¼Œã€‚ï¼›ï¼šï¼ï¼Ÿã€ï¼ˆï¼‰ã€Šã€‹ã€ã€‘'']$/.test(part)) {
                            currentSegment += part;
                            // æ ‡ç‚¹ç¬¦å·åç»“æŸå½“å‰åˆ†æ®µ
                            if (currentSegment.trim()) {
                                punctuationBasedSegments.push(currentSegment.trim());
                            }
                            currentSegment = '';
                        } else {
                            // å¦‚æœä¸æ˜¯æ ‡ç‚¹ç¬¦å·ï¼Œç´¯ç§¯åˆ°å½“å‰åˆ†æ®µ
                            currentSegment += part;
                        }
                    }
                    
                    // å¤„ç†æœ€åä¸€ä¸ªåˆ†æ®µ
                    if (currentSegment.trim()) {
                        punctuationBasedSegments.push(currentSegment.trim());
                    }
                    
                    // ç¬¬2æ­¥ï¼šåœ¨æ ‡ç‚¹ç¬¦å·åˆ†æ®µåŸºç¡€ä¸Šï¼Œå¯¹è¶…è¿‡å­—æ•°çš„æ®µè½åº”ç”¨è‡ªå®šä¹‰æ–­å¥è¯
                    let intermediateSegments = [];
                    
                    for (const segment of punctuationBasedSegments) {
                        // å¦‚æœæœ‰è‡ªå®šä¹‰æ–­å¥è¯ï¼Œå…ˆåº”ç”¨è‡ªå®šä¹‰æ–­å¥è¯
                        if (customBreakWords.length > 0) {
                            let processedSegment = segment;
                            let hasCustomBreak = false;
                            
                            for (const word of customBreakWords) {
                                if (word) {
                                    const regex = new RegExp(`(\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b)`, 'g');
                                    const beforeReplace = processedSegment;
                                    processedSegment = processedSegment.replace(regex, '\n$1');
                                    if (processedSegment !== beforeReplace) {
                                        hasCustomBreak = true;
                                    }
                                }
                            }
                            
                            // å¦‚æœåº”ç”¨äº†è‡ªå®šä¹‰æ–­å¥è¯ï¼ŒæŒ‰æ¢è¡Œç¬¦åˆ†å‰²
                            if (hasCustomBreak) {
                                const customSplitSegments = processedSegment.split('\n');
                                for (const subSegment of customSplitSegments) {
                                    if (subSegment.trim()) {
                                        intermediateSegments.push(subSegment.trim());
                                    }
                                }
                            } else {
                                // æ²¡æœ‰åº”ç”¨è‡ªå®šä¹‰æ–­å¥è¯ï¼Œä¿æŒåŸæ ·
                                intermediateSegments.push(segment);
                            }
                        } else {
                            // æ²¡æœ‰è‡ªå®šä¹‰æ–­å¥è¯ï¼Œç›´æ¥æ·»åŠ 
                            intermediateSegments.push(segment);
                        }
                    }
                    
                    // ç¬¬3æ­¥ï¼šå¯¹æ‰€æœ‰æ®µè½è¿›è¡Œä¸­ä½æ•°åˆ†æ®µæ£€æŸ¥ï¼Œç¡®ä¿æ¯ä¸€è¡Œéƒ½ç¬¦åˆå®½åº¦è¦æ±‚
                    // é€’å½’ä¸­ä½æ•°åˆ†æ®µå‡½æ•°ï¼Œç¡®ä¿æ¯ä¸€è¡Œéƒ½ä¸¥æ ¼ç¬¦åˆå®½åº¦è¦æ±‚
                    function recursiveMidPointSplit(text) {
                        if (text.length <= maxWidth) {
                            return [text];
                        }
                        
                        // è®¡ç®—ä¸­ä½æ•°åˆ†å‰²ç‚¹
                        const midPoint = Math.floor(text.length / 2);
                        
                        // å¯»æ‰¾ä¸­ä½æ•°é™„è¿‘æœ€åˆé€‚çš„åˆ†å‰²ç‚¹ï¼ˆç©ºæ ¼ä½ç½®ï¼‰
                        let bestSplitIndex = midPoint;
                        
                        // åœ¨ä¸­ä½æ•°å‰å20%èŒƒå›´å†…å¯»æ‰¾ç©ºæ ¼
                        const searchRange = Math.floor(text.length * 0.2);
                        const searchStart = Math.max(0, midPoint - searchRange);
                        const searchEnd = Math.min(text.length - 1, midPoint + searchRange);
                        
                        // ä¼˜å…ˆåœ¨ä¸­ä½æ•°åé¢å¯»æ‰¾ç©ºæ ¼
                        for (let i = midPoint; i <= searchEnd; i++) {
                            if (text[i] === ' ') {
                                bestSplitIndex = i;
                                break;
                            }
                        }
                        
                        // å¦‚æœåé¢æ²¡æ‰¾åˆ°ï¼Œåœ¨å‰é¢å¯»æ‰¾ç©ºæ ¼
                        if (bestSplitIndex === midPoint && text[midPoint] !== ' ') {
                            for (let i = midPoint - 1; i >= searchStart; i--) {
                                if (text[i] === ' ') {
                                    bestSplitIndex = i;
                                    break;
                                }
                            }
                        }
                        
                        // è¿›è¡Œåˆ†å‰²
                        const firstPart = text.substring(0, bestSplitIndex).trim();
                        const secondPart = text.substring(bestSplitIndex + 1).trim();
                        
                        // é€’å½’å¤„ç†æ¯ä¸€éƒ¨åˆ†ï¼Œç¡®ä¿éƒ½ç¬¦åˆå®½åº¦è¦æ±‚
                        const results = [];
                        if (firstPart) {
                            results.push(...recursiveMidPointSplit(firstPart));
                        }
                        if (secondPart) {
                            results.push(...recursiveMidPointSplit(secondPart));
                        }
                        
                        return results;
                    }
                    
                    // å¯¹æ‰€æœ‰ä¸­é—´æ®µè½è¿›è¡Œæœ€ç»ˆçš„å®½åº¦æ£€æŸ¥å’Œä¸­ä½æ•°åˆ†æ®µ
                    let finalSegments = [];
                    for (const segment of intermediateSegments) {
                        if (segment.length <= maxWidth) {
                            finalSegments.push(segment);
                        } else {
                            // ä½¿ç”¨é€’å½’å‡½æ•°å¤„ç†è¶…é•¿æ®µè½
                            const splitResults = recursiveMidPointSplit(segment);
                            finalSegments.push(...splitResults);
                        }
                    }
                    
                    result = finalSegments.join('\n');
                    
                } else if (mode === 'word_and_punctuation') {
                    // æŒ‰å•è¯å’Œæ ‡ç‚¹ç¬¦å·åˆ†æ®µ
                    // å…ˆæŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µï¼Œä½†æ’é™¤è¯ä¸­çš„æ’‡å·(apostrophe)å’Œå¼•å·
                    let text = processedText.replace(/([,.;:!?ï¼Œã€‚ï¼›ï¼šï¼ï¼Ÿã€ï¼ˆï¼‰ã€Šã€‹ã€ã€‘]|(?<!\w)'(?!\w)|(?<!\w)'(?!\w))/g, '$1\n');
                    
                    // åº”ç”¨è‡ªå®šä¹‰æ–­å¥è¯ - åªå¯¹è¶…è¿‡æœ€å¤§å®½åº¦çš„æ®µè½åº”ç”¨
                    if (customBreakWords.length > 0) {
                        const lines = text.split('\n');
                        const newLines = [];
                        
                        for (const line of lines) {
                            // åªæœ‰å½“æ®µè½é•¿åº¦è¶…è¿‡æœ€å¤§å®½åº¦æ—¶ï¼Œæ‰åº”ç”¨è‡ªå®šä¹‰æ–­å¥è¯
                            if (line.length > maxWidth) {
                                let processedLine = line;
                                // ä¸ºæ¯ä¸ªè‡ªå®šä¹‰æ–­å¥è¯åˆ›å»ºæ­£åˆ™è¡¨è¾¾å¼å¹¶åº”ç”¨
                                for (const word of customBreakWords) {
                                    if (word) {
                                        const regex = new RegExp(`(\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b)`, 'g');
                                        processedLine = processedLine.replace(regex, '\n$1');
                                    }
                                }
                                // å°†å¤„ç†åçš„è¡ŒæŒ‰æ–­å¥è¯æ‹†åˆ†å¹¶æ·»åŠ åˆ°ç»“æœä¸­
                                newLines.push(...processedLine.split('\n'));
                            } else {
                                newLines.push(line);
                            }
                        }
                        text = newLines.join('\n');
                    }
                    
                    const segments = text.split('\n');
                    const resultArray = [];
                    
                    // å¯¹æ¯ä¸ªåˆ†æ®µå†æŒ‰å•è¯åˆ†æ®µ
                    for (const segment of segments) {
                        if (!segment.trim()) continue;
                        
                        const words = segment.split(/\s+/);
                        const lines = [];
                        let currentLine = [];
                        let currentLength = 0;
                        
                        for (const word of words) {
                            const wordLength = word.length;
                            const spaceLength = currentLength > 0 ? 1 : 0;
                            
                            if (currentLength + wordLength + spaceLength <= maxWidth) {
                                currentLine.push(word);
                                currentLength += wordLength + spaceLength;
                            } else {
                                lines.push(currentLine.join(' '));
                                currentLine = [word];
                                currentLength = wordLength;
                            }
                        }
                        
                        if (currentLine.length > 0) {
                            lines.push(currentLine.join(' '));
                        }
                        
                        resultArray.push(lines.join('\n'));
                    }
                    
                    result = resultArray.join('\n');
                    
                } else if (mode === 'natural') {
                    // è‡ªç„¶è¯­è¨€åˆ†æ®µ - é‡å†™é€»è¾‘ï¼šå…ˆä¸¥æ ¼æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µï¼Œå†å¯¹è¶…è¿‡å­—æ•°çš„åˆ†æ®µè¿›è¡Œè‡ªç„¶è¯­è¨€å¤„ç†
                    
                    // ç¬¬ä¸€æ­¥ï¼šä¸¥æ ¼æŒ‰ç…§æ ‡ç‚¹ç¬¦å·è¿›è¡Œåˆ†æ®µï¼ˆåº•å±‚é€»è¾‘ï¼Œä¸å¯æ”¹åŠ¨ï¼‰
                    // åŒ¹é…ä¸­è‹±æ–‡å„ç§æ ‡ç‚¹ç¬¦å·ï¼Œä½†æ’é™¤è¯ä¸­çš„æ’‡å·å’Œå¼•å·
                    let punctuationSegments = processedText.split(/([,.;:!?ï¼Œã€‚ï¼›ï¼šï¼ï¼Ÿã€ï¼ˆï¼‰ã€Šã€‹ã€ã€‘]|(?<!\w)'(?!\w)|(?<!\w)'(?!\w))/);
                    
                    // æ¸…ç†å’Œé‡ç»„åˆ†æ®µï¼Œå°†æ ‡ç‚¹ç¬¦å·ä¸å‰é¢çš„æ–‡æœ¬åˆå¹¶
                    const cleanedSegments = [];
                    let currentSegment = '';
                    
                    for (let i = 0; i < punctuationSegments.length; i++) {
                        const part = punctuationSegments[i];
                        
                        if (!part) continue; // è·³è¿‡ç©ºå­—ç¬¦ä¸²
                        
                        // å¦‚æœæ˜¯æ ‡ç‚¹ç¬¦å·ï¼Œä¸å‰é¢çš„å†…å®¹åˆå¹¶
                        if (/^[,.;:!?ï¼Œã€‚ï¼›ï¼šï¼ï¼Ÿã€ï¼ˆï¼‰ã€Šã€‹ã€ã€‘'']$/.test(part)) {
                            currentSegment += part;
                            // æ ‡ç‚¹ç¬¦å·åç»“æŸå½“å‰åˆ†æ®µ
                            if (currentSegment.trim()) {
                                cleanedSegments.push(currentSegment.trim());
                            }
                            currentSegment = '';
                        } else {
                            // å¦‚æœä¸æ˜¯æ ‡ç‚¹ç¬¦å·ï¼Œç´¯ç§¯åˆ°å½“å‰åˆ†æ®µ
                            currentSegment += part;
                        }
                    }
                    
                    // å¤„ç†æœ€åä¸€ä¸ªåˆ†æ®µ
                    if (currentSegment.trim()) {
                        cleanedSegments.push(currentSegment.trim());
                    }
                    
                    // ç¬¬äºŒæ­¥ï¼šåˆ¤æ–­æ¯ä¸ªåˆ†æ®µçš„å­—æ•°ï¼Œå¯¹è¶…è¿‡é™å®šå­—æ•°çš„åˆ†æ®µè¿›è¡Œè‡ªç„¶è¯­è¨€å¤„ç†
                    const finalSegments = [];
                    
                    for (const segment of cleanedSegments) {
                        // å¦‚æœåˆ†æ®µå­—æ•°æœªè¶…è¿‡é™å®šå­—æ•°ï¼Œç›´æ¥ä¿ç•™
                        if (segment.length <= maxWidth) {
                            finalSegments.push(segment);
                            continue;
                        }
                        
                        // å¦‚æœåˆ†æ®µå­—æ•°è¶…è¿‡äº†é™å®šå­—æ•°ï¼Œè¿›è¡Œè‡ªç„¶è¯­è¨€å¤„ç†
                        let processedSegment = segment;
                        
                        // åº”ç”¨è‡ªå®šä¹‰æ–­å¥è¯ï¼ˆå¦‚æœå¯ç”¨ä¸”æœ‰è®¾ç½®ï¼‰ - æ³¨æ„ï¼šåªåœ¨è¶…é•¿åˆ†æ®µä¸Šåº”ç”¨
                        if (customBreakWords.length > 0) {
                            for (const word of customBreakWords) {
                                if (word) {
                                    const regex = new RegExp(`(\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b)`, 'g');
                                    processedSegment = processedSegment.replace(regex, '\n$1');
                                }
                            }
                            
                            // å¦‚æœåº”ç”¨äº†è‡ªå®šä¹‰æ–­å¥è¯ï¼ŒæŒ‰æ¢è¡Œç¬¦åˆ†å‰²å¹¶æ£€æŸ¥æ¯ä¸ªå­æ®µ
                            const customSplitSegments = processedSegment.split('\n');
                            for (const subSegment of customSplitSegments) {
                                if (!subSegment.trim()) continue;
                                
                                if (subSegment.length <= maxWidth) {
                                    finalSegments.push(subSegment.trim());
                                } else {
                                    // å¦‚æœå­æ®µä»ç„¶è¶…é•¿ï¼Œç”¨å•è¯åˆ†æ®µ
                                    const words = subSegment.trim().split(/\s+/);
                                    let currentLine = [];
                                    let currentLength = 0;
                                    
                                    for (const word of words) {
                                        const wordLength = word.length;
                                        const spaceLength = currentLength > 0 ? 1 : 0;
                                        
                                        if (currentLength + wordLength + spaceLength <= maxWidth) {
                                            currentLine.push(word);
                                            currentLength += wordLength + spaceLength;
                                        } else {
                                            if (currentLine.length > 0) {
                                                finalSegments.push(currentLine.join(' '));
                                            }
                                            currentLine = [word];
                                            currentLength = wordLength;
                                        }
                                    }
                                    
                                    if (currentLine.length > 0) {
                                        finalSegments.push(currentLine.join(' '));
                                    }
                                }
                            }
                        } else {
                                                         // æ²¡æœ‰è‡ªå®šä¹‰æ–­å¥è¯ï¼Œä½¿ç”¨è‡ªç„¶è¯­è¨€è¿æ¥è¯è¿›è¡Œåˆ†æ®µ
                            const naturalBreakPoints = [
                                // è‹±æ–‡å¸¸è§çš„è¿æ¥è¯å’ŒçŸ­è¯­
                                /\s+(and|but|however|therefore|moreover|furthermore|consequently|nevertheless)\s+/gi,
                                /\s+(in\s+addition|on\s+the\s+other\s+hand|for\s+example|in\s+fact|as\s+a\s+result)\s+/gi,
                                /\s+(in\s+contrast|instead|meanwhile|whereas|though|although|unless|since|while|because|yet|still)\s+/gi,
                                
                                // ä¸­æ–‡å¸¸è§è¿æ¥è¯å’ŒçŸ­è¯­
                                /(ç„¶è€Œ|ä½†æ˜¯|ä¸è¿‡|å› æ­¤|æ‰€ä»¥|å› è€Œ|æ­¤å¤–|å¦å¤–|è€Œä¸”|å†µä¸”|ä¸ä»…å¦‚æ­¤|ä¸æ­¤åŒæ—¶|ç›¸å|æ€»ä¹‹|æ€»è€Œè¨€ä¹‹|å°½ç®¡å¦‚æ­¤)/g
                            ];
                            
                            let subSegments = [processedSegment];
                            
                            // åœ¨è‡ªç„¶åœé¡¿å¤„è¿›è¡Œåˆ†æ®µ - åªæœ‰åœ¨åˆ†æ®µåä»éœ€è¦è¿›ä¸€æ­¥åˆ†æ®µæ—¶æ‰è¿›è¡Œ
                            for (const pattern of naturalBreakPoints) {
                                let newSubSegments = [];
                                
                                for (const subSegment of subSegments) {
                                    if (subSegment.length <= maxWidth) {
                                        newSubSegments.push(subSegment);
                                        continue;
                                    }
                                    
                                    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ‰¾åˆ°æ‰€æœ‰åŒ¹é…çš„è¿æ¥è¯ä½ç½®
                                    const matches = [];
                                    let match;
                                    const regex = new RegExp(pattern.source, pattern.flags);
                                    
                                    while ((match = regex.exec(subSegment)) !== null) {
                                        matches.push({
                                            index: match.index,
                                            length: match[0].length,
                                            text: match[0]
                                        });
                                        // é˜²æ­¢æ— é™å¾ªç¯
                                        if (!pattern.global) break;
                                    }
                                    
                                    if (matches.length > 0) {
                                        let bestSplit = null;
                                        
                                        // æ‰¾åˆ°æœ€ä½³çš„åˆ†å‰²ç‚¹ï¼šåˆ†å‰²åä¸¤éƒ¨åˆ†éƒ½å°½å¯èƒ½æ¥è¿‘ä½†ä¸è¶…è¿‡maxWidth
                                        for (const matchInfo of matches) {
                                            const beforePart = subSegment.substring(0, matchInfo.index).trim();
                                            const afterStart = matchInfo.index + matchInfo.length;
                                            const afterPart = subSegment.substring(afterStart).trim();
                                            const afterWithConnector = matchInfo.text.trim() + ' ' + afterPart;
                                            
                                            // æ£€æŸ¥åˆ†å‰²æ˜¯å¦æœ‰æ„ä¹‰ï¼šä¸¤éƒ¨åˆ†éƒ½åº”è¯¥æ¯”åŸæ–‡æœ¬çŸ­ï¼Œå¹¶ä¸”è‡³å°‘ä¸€éƒ¨åˆ†è¶…è¿‡äº†maxWidth
                                            if (beforePart && afterPart && 
                                                (beforePart.length > maxWidth || afterWithConnector.length > maxWidth)) {
                                                
                                                // å¦‚æœå‰åŠéƒ¨åˆ†ä¸è¶…è¿‡maxWidthï¼Œè€ŒååŠéƒ¨åˆ†è¶…è¿‡ï¼Œè¿™æ˜¯ä¸€ä¸ªå¥½çš„åˆ†å‰²ç‚¹
                                                if (beforePart.length <= maxWidth && afterWithConnector.length > maxWidth) {
                                                    bestSplit = {
                                                        before: beforePart,
                                                        after: afterWithConnector
                                                    };
                                                    break;
                                                }
                                                // å¦‚æœä¸¤éƒ¨åˆ†éƒ½è¶…è¿‡maxWidthï¼Œä¹Ÿå¯ä»¥åˆ†å‰²ï¼ˆè‡³å°‘å‡å°‘äº†ä¸€éƒ¨åˆ†çš„é•¿åº¦ï¼‰
                                                else if (beforePart.length > maxWidth && afterWithConnector.length > maxWidth) {
                                                    bestSplit = {
                                                        before: beforePart,
                                                        after: afterWithConnector
                                                    };
                                                    break;
                                                }
                                            }
                                        }
                                        
                                        if (bestSplit) {
                                            newSubSegments.push(bestSplit.before);
                                            newSubSegments.push(bestSplit.after);
                                        } else {
                                            // æ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„åˆ†å‰²ç‚¹ï¼Œä¿æŒåŸæ ·
                                            newSubSegments.push(subSegment);
                                        }
                                    } else {
                                        newSubSegments.push(subSegment);
                                    }
                                }
                                
                                subSegments = newSubSegments.filter(s => s && s.trim());
                            }
                            
                            // å¤„ç†ç»“æœï¼Œåªå¯¹æ˜¾è‘—è¶…é•¿çš„å­æ®µè¿›è¡Œå•è¯åˆ†æ®µ
                            for (const subSegment of subSegments) {
                                if (!subSegment.trim()) continue;
                                
                                // ç»™äºˆä¸€å®šçš„å®½å®¹åº¦ï¼šå¦‚æœè¶…å‡ºä¸å¤šï¼ˆæ¯”å¦‚ä¸è¶…è¿‡maxWidthçš„1.2å€ï¼‰ï¼Œå°±ä¿æŒåŸæ ·
                                if (subSegment.length <= maxWidth * 1.2) {
                                    finalSegments.push(subSegment.trim());
                                } else {
                                    // åªæœ‰æ˜¾è‘—è¶…é•¿çš„å­æ®µæ‰ç”¨å•è¯åˆ†æ®µå¤„ç†
                                    const words = subSegment.trim().split(/\s+/);
                                    let currentLine = [];
                                    let currentLength = 0;
                                    
                                    for (const word of words) {
                                        const wordLength = word.length;
                                        const spaceLength = currentLength > 0 ? 1 : 0;
                                        
                                        if (currentLength + wordLength + spaceLength <= maxWidth) {
                                            currentLine.push(word);
                                            currentLength += wordLength + spaceLength;
                                        } else {
                                            if (currentLine.length > 0) {
                                                finalSegments.push(currentLine.join(' '));
                                            }
                                            currentLine = [word];
                                            currentLength = wordLength;
                                        }
                                    }
                                    
                                    if (currentLine.length > 0) {
                                        finalSegments.push(currentLine.join(' '));
                                    }
                                }
                            }
                        }
                    }
                    
                    result = finalSegments.join('\n');
                    
                } else if (mode === 'quotes') {
                    // æŒ‰å¼•å·æ–­å¥ - åœ¨æ¯ä¸ªåŒå¼•å·ç»“æŸåæ–­å¥
                    
                    // åœ¨å¼•å·åæ–­å¥
                    result = text.replace(/"([^"]*)"/g, '"$1"\n');
                    
                    // å¤„ç†è¿‡é•¿çš„è¡Œï¼ˆä¸åœ¨å¼•å·ä¸­çš„æ–‡æœ¬ï¼‰
                    if (result.length > 0) {
                        const lines = result.split('\n');
                        const processedLines = [];
                        
                        for (const line of lines) {
                            // è·³è¿‡ç©ºè¡Œ
                            if (!line.trim()) {
                                continue;
                            }
                            
                            // æ£€æŸ¥è¡Œæ˜¯å¦å¤ªé•¿ï¼Œå¦‚æœæ˜¯åˆ™è¿›ä¸€æ­¥åˆ†æ®µ
                            if (line.length > maxWidth) {
                                // æŒ‰å•è¯åˆ†æ®µ
                                const words = line.split(/\s+/);
                                let currentLine = [];
                                let currentLength = 0;
                                
                                for (const word of words) {
                                    const wordLength = word.length;
                                    const spaceLength = currentLength > 0 ? 1 : 0;
                                    
                                    if (currentLength + wordLength + spaceLength <= maxWidth) {
                                        currentLine.push(word);
                                        currentLength += wordLength + spaceLength;
                                    } else {
                                        processedLines.push(currentLine.join(' '));
                                        currentLine = [word];
                                        currentLength = wordLength;
                                    }
                                }
                                
                                if (currentLine.length > 0) {
                                    processedLines.push(currentLine.join(' '));
                                }
                            } else {
                                processedLines.push(line);
                            }
                        }
                        
                        result = processedLines.join('\n');
                    }
                    
                    // ç›´æ¥è¿”å›ç»“æœï¼Œä¸éœ€è¦æ¢å¤å¼•å·å†…å®¹
                    return result;
                    
                } else {
                    return "é”™è¯¯: æ¨¡å¼å¿…é¡»æ˜¯ 'char', 'word', 'sentence', 'punctuation', 'word_and_punctuation', 'natural' æˆ– 'quotes'";
                }
                
                // æ¢å¤å¼•å·å†…çš„å†…å®¹ï¼ˆä»…é’ˆå¯¹équotesæ¨¡å¼ï¼‰
                if (mode !== 'quotes') {
                    for (let i = 0; i < quotedTexts.length; i++) {
                        const placeholder = `__QUOTED_TEXT_${i}__`;
                        const quotedContent = quotedTexts[i];
                        
                        // æ¢å¤å¼•å·å†…å®¹ï¼Œå¹¶æŒ‰ç…§å­—ç¬¦æ•°åˆ†æ®µå¤„ç†
                        if (quotedContent.length > maxWidth) {
                            // å¦‚æœå¼•å·å†…å†…å®¹è¾ƒé•¿ï¼ŒæŒ‰å­—ç¬¦åˆ†æ®µ
                            const parts = [];
                            for (let j = 0; j < quotedContent.length; j += maxWidth) {
                                parts.push(quotedContent.substring(j, j + maxWidth));
                            }
                            // ä¸ºæ¯ä¸ªéƒ¨åˆ†æ·»åŠ å¼•å·
                            const quotedParts = parts.map((part, index) => {
                                // ç¬¬ä¸€éƒ¨åˆ†åŠ å¼€å§‹å¼•å·ï¼Œæœ€åéƒ¨åˆ†åŠ ç»“æŸå¼•å·ï¼Œä¸­é—´éƒ¨åˆ†ä¸æ·»åŠ 
                                if (parts.length === 1) return `"${part}"`; // åªæœ‰ä¸€éƒ¨åˆ†çš„æƒ…å†µ
                                if (index === 0) return `"${part}`; // ç¬¬ä¸€éƒ¨åˆ†
                                if (index === parts.length - 1) return `${part}"`; // æœ€åéƒ¨åˆ†
                                return part; // ä¸­é—´éƒ¨åˆ†
                            });
                            result = result.replace(placeholder, quotedParts.join('\n'));
                        } else {
                            // å¦‚æœå¼•å·å†…å†…å®¹è¾ƒçŸ­ï¼Œç›´æ¥æ¢å¤
                            result = result.replace(placeholder, `"${quotedContent}"`);
                        }
                    }
                }
                
                return result;
            }
            
            // åˆå§‹æ ¼å¼åŒ–ä¸€æ¬¡
            formatBtn.click();
        });
    </script>
</body>
</html> 