<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–‡æœ¬æ ¼å¼åŒ–å·¥å…·</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <!-- SweetAlert2 -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Microsoft YaHei', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
        }
        
        .main-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            margin: 2rem auto;
            max-width: 1200px;
        }
        
        .header-section {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border-radius: 20px 20px 0 0;
            padding: 2rem;
            text-align: center;
        }
        
        .header-section h1 {
            margin: 0;
            font-weight: 300;
            font-size: 2.5rem;
        }
        
        .header-section p {
            margin: 0.5rem 0 0 0;
            opacity: 0.9;
        }
        
        .content-section {
            padding: 2rem;
        }
        
        .card {
            border: none;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            margin-bottom: 1.5rem;
        }
        
        .card-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px 15px 0 0 !important;
            border: none;
            padding: 1rem 1.5rem;
        }
        
        .form-label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 0.5rem;
        }
        
        .form-control, .form-select {
            border-radius: 10px;
            border: 1px solid #e3e6f0;
            padding: 0.75rem 1rem;
            transition: all 0.3s ease;
        }
        
        .form-control:focus, .form-select:focus {
            border-color: #4facfe;
            box-shadow: 0 0 0 0.2rem rgba(79, 172, 254, 0.25);
        }
        
        .btn {
            border-radius: 10px;
            padding: 0.75rem 1.5rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border: none;
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #00f2fe 0%, #4facfe 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            border: none;
        }
        
        .btn-success:hover {
            background: linear-gradient(135deg, #38ef7d 0%, #11998e 100%);
            transform: translateY(-2px);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
            border: none;
        }
        
        .btn-info {
            background: linear-gradient(135deg, #ff9a56 0%, #ff6b35 100%);
            border: none;
        }
        
        .btn-info:hover {
            background: linear-gradient(135deg, #ff6b35 0%, #ff9a56 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #ffb347 100%);
            border: none;
            color: #212529;
        }
        
        .btn-warning:hover {
            background: linear-gradient(135deg, #ffb347 0%, #ffc107 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 193, 7, 0.4);
            color: #212529;
        }
        
        .result-area {
            white-space: pre;
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 10px;
            min-height: 200px;
            max-height: 810px;
            overflow-x: auto;
            overflow-y: auto;
            font-family: 'Courier New', 'Monaco', monospace;
            border: 1px solid #e3e6f0;
            font-size: 0.9rem;
            line-height: 1.4;
            resize: vertical;
            width: 100%;
            box-sizing: border-box;
        }
        
        .icon-text {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .feature-badge {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            color: #8b4513;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .custom-textarea {
            height: 180px;
            resize: vertical;
        }
        
        @media (max-width: 768px) {
            .main-container {
                margin: 1rem;
                border-radius: 15px;
            }
            
            .header-section {
                padding: 1.5rem 1rem;
                border-radius: 15px 15px 0 0;
            }
            
            .header-section h1 {
                font-size: 2rem;
            }
            
            .content-section {
                padding: 1.5rem 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- å¤´éƒ¨åŒºåŸŸ -->
        <div class="header-section">
            <h1><i class="bi bi-textarea-t"></i> æ™ºèƒ½æ–‡æœ¬æ ¼å¼åŒ–å·¥å…·</h1>
            <p>æ”¯æŒå¤šç§åˆ†æ®µæ¨¡å¼çš„ä¸“ä¸šæ–‡æœ¬å¤„ç†å·¥å…·</p>
        </div>
        
        <!-- å†…å®¹åŒºåŸŸ -->
        <div class="content-section">
            <!-- è¾“å…¥æ–‡æœ¬å¡ç‰‡ -->
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <span class="icon-text">
                            <i class="bi bi-pencil-square"></i>
                            æ–‡æœ¬è¾“å…¥
                        </span>
                    </h5>
                </div>
                <div class="card-body">
                    <label for="input-text" class="form-label">è¾“å…¥éœ€è¦æ ¼å¼åŒ–çš„æ–‡æœ¬:</label>
                    <textarea id="input-text" class="form-control custom-textarea" placeholder="è¯·åœ¨æ­¤è¾“å…¥é•¿æ–‡æœ¬..."></textarea>
                </div>
            </div>
            
            <!-- æ ¼å¼åŒ–è®¾ç½®å¡ç‰‡ -->
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <span class="icon-text">
                            <i class="bi bi-gear"></i>
                            æ ¼å¼åŒ–è®¾ç½®
                            <span class="feature-badge">æ¨èæŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µ</span>
                        </span>
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row g-3">
                        <div class="col-md-6">
                            <label for="format-mode" class="form-label">
                                <i class="bi bi-list-ul text-primary"></i> åˆ†æ®µæ¨¡å¼:
                            </label>
                            <select id="format-mode" class="form-select">
                                <option value="char">æŒ‰å­—ç¬¦åˆ†æ®µ</option>
                                <option value="word">æŒ‰å•è¯åˆ†æ®µ</option>
                                <option value="sentence">æŒ‰å¥å­åˆ†æ®µ</option>
                                <option value="punctuation" selected>â­ æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µ (æ¨è)</option>
                                <option value="word_and_punctuation">æŒ‰å•è¯å’Œæ ‡ç‚¹ç¬¦å·åˆ†æ®µ</option>
                                <option value="natural">è‡ªç„¶è¯­è¨€åˆ†æ®µ</option>
                            </select>
                        </div>
                        
                        <div class="col-md-6">
                            <label for="max-width" class="form-label">
                                <i class="bi bi-arrows-expand text-success"></i> æ¯è¡Œæœ€å¤§å®½åº¦:
                            </label>
                            <input type="number" id="max-width" class="form-control" value="69" min="10" max="2000">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- æ›¿æ¢åŠŸèƒ½å¡ç‰‡ -->
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <span class="icon-text">
                            <i class="bi bi-arrow-left-right"></i>
                            æ–‡æœ¬æ›¿æ¢ (å¯é€‰)
                        </span>
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row g-3">
                        <div class="col-md-4">
                            <label for="find-text" class="form-label">æŸ¥æ‰¾:</label>
                            <input type="text" id="find-text" class="form-control" placeholder="è¾“å…¥è¦æ›¿æ¢çš„æ–‡æœ¬">
                        </div>
                        
                        <div class="col-md-4">
                            <label for="replace-text" class="form-label">æ›¿æ¢ä¸º:</label>
                            <input type="text" id="replace-text" class="form-control" placeholder="è¾“å…¥æ›¿æ¢åçš„æ–‡æœ¬">
                        </div>
                        
                        <div class="col-md-4 d-flex align-items-end">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="enable-replace">
                                <label class="form-check-label" for="enable-replace">
                                    å¯ç”¨æ›¿æ¢åŠŸèƒ½
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- è‡ªå®šä¹‰æ–­å¥å¡ç‰‡ -->
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <span class="icon-text">
                            <i class="bi bi-scissors"></i>
                            è‡ªå®šä¹‰æ–­å¥ (é«˜çº§)
                        </span>
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row g-3">
                        <div class="col-md-9">
                            <label for="custom-break-words" class="form-label">è‡ªå®šä¹‰æ–­å¥è¯ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰:</label>
                            <input type="text" id="custom-break-words" class="form-control" placeholder="è¾“å…¥è¦ä½œä¸ºæ–­å¥ç‚¹çš„å•è¯æˆ–çŸ­è¯­ï¼Œå¦‚: ä¾‹å¦‚,æ¯”å¦‚,ä¾‹å­">
                            <div class="form-text">
                                <i class="bi bi-info-circle text-primary"></i>
                                æ­¤åŠŸèƒ½åœ¨"æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µ"ã€"æŒ‰å•è¯å’Œæ ‡ç‚¹ç¬¦å·åˆ†æ®µ"å’Œ"è‡ªç„¶è¯­è¨€åˆ†æ®µ"æ¨¡å¼ä¸‹æœ‰æ•ˆ
                            </div>
                            <div class="d-flex gap-2 mt-2">
                                <button id="save-break-words" class="btn btn-success btn-sm flex-fill">
                                    <i class="bi bi-save"></i> ä¿å­˜æ–­å¥è¯
                                </button>
                                <button id="clear-break-words" class="btn btn-danger btn-sm flex-fill">
                                    <i class="bi bi-trash"></i> æ¸…é™¤æ–­å¥è¯
                                </button>
                            </div>
                        </div>
                        
                        <div class="col-md-3 d-flex align-items-end">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="enable-custom-break" checked>
                                <label class="form-check-label" for="enable-custom-break">
                                    å¯ç”¨è‡ªå®šä¹‰æ–­å¥
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- æ“ä½œæŒ‰é’® -->
            <div class="text-center mb-4">
                <button id="format-btn" class="btn btn-primary btn-lg">
                    <i class="bi bi-play-circle"></i> æ ¼å¼åŒ–æ–‡æœ¬
                </button>
            </div>
            
            <!-- ç»“æœè¾“å‡ºå¡ç‰‡ -->
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">
                        <span class="icon-text">
                            <i class="bi bi-file-text"></i>
                            æ ¼å¼åŒ–ç»“æœ
                        </span>
                    </h5>
                    <div class="d-flex gap-2">
                        <button id="remove-punctuation-btn" class="btn btn-warning btn-sm">
                            <i class="bi bi-eraser"></i> å»é™¤æ ‡ç‚¹
                        </button>
                        <button id="copy-btn" class="btn btn-info btn-sm">
                            <i class="bi bi-clipboard"></i> å¤åˆ¶æ–‡æœ¬
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <textarea id="output-text" class="result-area form-control" placeholder="æ ¼å¼åŒ–åçš„æ–‡æœ¬å°†æ˜¾ç¤ºåœ¨è¿™é‡Œï¼Œæ‚¨å¯ä»¥ç›´æ¥ç¼–è¾‘..."></textarea>
                </div>
            </div>
        </div>
    </div>
    
    <!-- é¡µè„š -->
    <footer class="text-center py-4">
        <div class="container">
            <p class="mb-0 text-light">
                <i class="bi bi-heart-fill text-danger"></i>
                æ–‡æœ¬æ ¼å¼åŒ–å·¥å…· &copy; 2025 - è®©æ–‡æœ¬å¤„ç†æ›´ç®€å•
            </p>
        </div>
         </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // æ™ºèƒ½è°ƒæ•´textareaé«˜åº¦çš„å‡½æ•°
            function smartResizeTextarea(textarea) {
                // ä¸´æ—¶é‡ç½®é«˜åº¦ä»¥è·å–æ­£ç¡®çš„scrollHeight
                textarea.style.height = 'auto';
                
                // è®¾ç½®æœ€å°å’Œæœ€å¤§é«˜åº¦
                const minHeight = 200;
                const maxHeight = 810;
                
                // è·å–å†…å®¹å®é™…é«˜åº¦
                const contentHeight = textarea.scrollHeight;
                
                // è®¡ç®—æœ€ç»ˆé«˜åº¦ï¼šåœ¨æœ€å°å€¼å’Œæœ€å¤§å€¼ä¹‹é—´
                const finalHeight = Math.min(Math.max(contentHeight, minHeight), maxHeight);
                
                // è®¾ç½®æ–°é«˜åº¦
                textarea.style.height = finalHeight + 'px';
                
                // å¦‚æœå†…å®¹è¶…è¿‡æœ€å¤§é«˜åº¦ï¼Œæ˜¾ç¤ºæ»šåŠ¨æ¡
                if (contentHeight > maxHeight) {
                    textarea.style.overflowY = 'auto';
                } else {
                    textarea.style.overflowY = 'hidden';
                }
            }
            
            // æ˜¾ç¤ºæ¬¢è¿å¼¹çª—
            Swal.fire({
                title: 'ğŸ‰ æ¬¢è¿ä½¿ç”¨æ–‡æœ¬æ ¼å¼åŒ–å·¥å…·',
                html: `
                    <div style="text-align: left; line-height: 1.6;">
                        <p style="text-align: center; color: #2196F3; font-size: 18px; margin-bottom: 20px;">
                            ğŸ’¡ æ¨èä½¿ç”¨ <strong style="color: #e74c3c;">æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µ</strong> æ¨¡å¼ï¼Œå…¶å®ƒæ¨¡å¼å¯èƒ½å­˜åœ¨æœªçŸ¥é—®é¢˜
                        </p>
                        <div style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <h4 style="color: #333; margin-bottom: 10px;">ğŸ“‹ æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µé€»è¾‘ï¼š</h4>
                            <ol style="margin: 0; padding-left: 20px;">
                                <li style="margin-bottom: 8px;"><strong>ç¬¬ä¸€æ­¥ï¼š</strong>å…ˆæŒ‰æ ‡ç‚¹ç¬¦å·æ–­å¥ï¼ˆåº•å±‚é€»è¾‘ï¼Œä¼˜å…ˆçº§æœ€é«˜ï¼‰</li>
                                <li style="margin-bottom: 8px;"><strong>ç¬¬äºŒæ­¥ï¼š</strong>æ ¹æ®è‡ªå®šä¹‰å•è¯æ–­å¥ï¼ˆåªæ–­è¶…è¿‡å­—ç¬¦é™åˆ¶çš„å¥å­ï¼‰</li>
                                <li style="margin-bottom: 8px;"><strong>ç¬¬ä¸‰æ­¥ï¼š</strong>å¦‚æœæ— è‡ªå®šä¹‰å•è¯ï¼Œåˆ™å–ä¸­ä½æ•°æ–­å¥</li>
                            </ol>
                        </div>
                        <p style="text-align: center; color: #666; font-size: 14px;">
                            ğŸ’¡ è¿™ç§åˆ†æ®µæ–¹å¼èƒ½ä¿æŒæ–‡æœ¬çš„é€»è¾‘å®Œæ•´æ€§ï¼ŒåŒæ—¶æä¾›çµæ´»çš„è‡ªå®šä¹‰é€‰é¡¹
                        </p>
                    </div>
                `,
                icon: 'info',
                confirmButtonText: 'å¼€å§‹ä½¿ç”¨',
                confirmButtonColor: '#4CAF50',
                width: '600px',
                backdrop: true,
                allowOutsideClick: false
            });
            
            // è·å–DOMå…ƒç´ 
            const inputText = document.getElementById('input-text');
            const formatMode = document.getElementById('format-mode');
            const maxWidth = document.getElementById('max-width');
            const formatBtn = document.getElementById('format-btn');
            const outputText = document.getElementById('output-text');
            const customBreakWordsInput = document.getElementById('custom-break-words');
            const saveBreakWordsBtn = document.getElementById('save-break-words');
            const clearBreakWordsBtn = document.getElementById('clear-break-words');
            const copyBtn = document.getElementById('copy-btn');
            const removePunctuationBtn = document.getElementById('remove-punctuation-btn');
            
            // ä¸ºè¾“å‡ºæ–‡æœ¬æ¡†æ·»åŠ æ™ºèƒ½è°ƒæ•´é«˜åº¦åŠŸèƒ½
            outputText.addEventListener('input', function() {
                smartResizeTextarea(this);
            });
            
            // åˆå§‹åŒ–è¾“å‡ºæ–‡æœ¬æ¡†é«˜åº¦
            smartResizeTextarea(outputText);
            
            // åŠ è½½ä¿å­˜çš„æ–­å¥è¯
            if (localStorage.getItem('customBreakWords')) {
                customBreakWordsInput.value = localStorage.getItem('customBreakWords');
            }
            
            // ä¿å­˜æ–­å¥è¯äº‹ä»¶
            saveBreakWordsBtn.addEventListener('click', function() {
                const breakWords = customBreakWordsInput.value.trim();
                if (breakWords) {
                    localStorage.setItem('customBreakWords', breakWords);
                    alert('æ–­å¥è¯å·²ä¿å­˜ï¼');
                } else {
                    alert('è¯·å…ˆè¾“å…¥æ–­å¥è¯å†ä¿å­˜');
                }
            });
            
            // æ¸…é™¤æ–­å¥è¯äº‹ä»¶
            clearBreakWordsBtn.addEventListener('click', function() {
                if (confirm('ç¡®å®šè¦æ¸…é™¤ä¿å­˜çš„æ–­å¥è¯å—ï¼Ÿ')) {
                    localStorage.removeItem('customBreakWords');
                    customBreakWordsInput.value = '';
                    alert('æ–­å¥è¯å·²æ¸…é™¤ï¼');
                }
            });
            
            // å»é™¤æ ‡ç‚¹ç¬¦å·åŠŸèƒ½äº‹ä»¶
            removePunctuationBtn.addEventListener('click', function() {
                let currentText = outputText.value;
                
                if (!currentText || !currentText.trim()) {
                    alert('æ²¡æœ‰å†…å®¹å¯ä»¥å¤„ç†ï¼Œè¯·å…ˆæ ¼å¼åŒ–æ–‡æœ¬ï¼');
                    return;
                }
                
                                 // å»é™¤æ ‡ç‚¹ç¬¦å·ä½†ä¿ç•™æˆå¯¹ç¬¦å·çš„å‡½æ•°
                 function removePunctuationKeepPairs(text) {
                     return text
                         // åˆ é™¤å•ç‹¬çš„æ ‡ç‚¹ç¬¦å·ï¼šå¥å·ã€é€—å·ã€åˆ†å·ã€å†’å·ã€æ„Ÿå¹å·ã€é—®å·ã€é¡¿å·
                         .replace(/[ï¼Œã€‚ï¼›ï¼šï¼ï¼Ÿã€]/g, ' ')
                         // åˆ é™¤è‹±æ–‡å•ç‹¬æ ‡ç‚¹ç¬¦å·
                         .replace(/[,.;:!?]/g, ' ')
                         // ä¿ç•™æˆå¯¹æ ‡ç‚¹ç¬¦å·ï¼šä¹¦åå·ã€Šã€‹ã€å¼•å·""''ã€æ‹¬å·ï¼ˆï¼‰ã€ã€‘()ã€ç ´æŠ˜å·â€”â€”ã€çœç•¥å·â€¦â€¦
                         // è¿™äº›ç¬¦å·ä¸è¿›è¡Œåˆ é™¤å¤„ç†
                         // æ¸…ç†å¤šä½™çš„ç©ºæ ¼ï¼Œä½†ä¿ç•™æ¢è¡Œç¬¦ï¼šåªå¤„ç†ç©ºæ ¼å’Œåˆ¶è¡¨ç¬¦
                         .replace(/[ \t]+/g, ' ')
                         // æ¸…ç†è¡Œé¦–è¡Œæœ«çš„ç©ºæ ¼ï¼Œä½†ä¿ç•™æ¢è¡Œç¬¦
                         .replace(/^[ \t]+|[ \t]+$/gm, '');
                 }
                
                const processedText = removePunctuationKeepPairs(currentText);
                outputText.value = processedText;
                
                // æ™ºèƒ½è°ƒæ•´æ–‡æœ¬æ¡†é«˜åº¦
                smartResizeTextarea(outputText);
                
                // ä¸´æ—¶æ”¹å˜æŒ‰é’®æ–‡å­—å’Œé¢œè‰²æä¾›åé¦ˆ
                const originalText = removePunctuationBtn.innerHTML;
                const originalColor = removePunctuationBtn.style.backgroundColor;
                removePunctuationBtn.innerHTML = '<i class="bi bi-check-circle"></i> å·²å¤„ç†';
                removePunctuationBtn.style.backgroundColor = '#28a745';
                
                setTimeout(() => {
                    removePunctuationBtn.innerHTML = originalText;
                    removePunctuationBtn.style.backgroundColor = originalColor;
                }, 2000);
            });
            
            // å¤åˆ¶åŠŸèƒ½äº‹ä»¶
            copyBtn.addEventListener('click', async function() {
                const textToCopy = outputText.value;
                
                if (!textToCopy || !textToCopy.trim()) {
                    alert('æ²¡æœ‰å†…å®¹å¯ä»¥å¤åˆ¶ï¼Œè¯·å…ˆæ ¼å¼åŒ–æ–‡æœ¬ï¼');
                    return;
                }
                
                try {
                    // ä½¿ç”¨ç°ä»£ Clipboard API
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(textToCopy);
                        // ä¸´æ—¶æ”¹å˜æŒ‰é’®æ–‡å­—å’Œé¢œè‰²æä¾›åé¦ˆ
                        const originalText = copyBtn.textContent;
                        const originalColor = copyBtn.style.backgroundColor;
                        copyBtn.textContent = 'å¤åˆ¶æˆåŠŸï¼';
                        copyBtn.style.backgroundColor = '#4CAF50';
                        
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.style.backgroundColor = originalColor;
                        }, 2000);
                    } else {
                        // é™çº§åˆ°ä¼ ç»Ÿæ–¹æ³•
                        const textArea = document.createElement('textarea');
                        textArea.value = textToCopy;
                        textArea.style.position = 'fixed';
                        textArea.style.left = '-999999px';
                        textArea.style.top = '-999999px';
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        
                        if (document.execCommand('copy')) {
                            // ä¸´æ—¶æ”¹å˜æŒ‰é’®æ–‡å­—å’Œé¢œè‰²æä¾›åé¦ˆ
                            const originalText = copyBtn.textContent;
                            const originalColor = copyBtn.style.backgroundColor;
                            copyBtn.textContent = 'å¤åˆ¶æˆåŠŸï¼';
                            copyBtn.style.backgroundColor = '#4CAF50';
                            
                            setTimeout(() => {
                                copyBtn.textContent = originalText;
                                copyBtn.style.backgroundColor = originalColor;
                            }, 2000);
                        } else {
                            alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬è¿›è¡Œå¤åˆ¶');
                        }
                        
                        document.body.removeChild(textArea);
                    }
                } catch (error) {
                    console.error('å¤åˆ¶å¤±è´¥:', error);
                    alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬è¿›è¡Œå¤åˆ¶');
                }
            });
            
            // æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            formatBtn.addEventListener('click', function() {
                try {
                    const text = inputText.value;
                    const mode = formatMode.value;
                    const width = parseInt(maxWidth.value);
                    
                    if (!text.trim()) {
                        outputText.value = "è¯·è¾“å…¥è¦æ ¼å¼åŒ–çš„æ–‡æœ¬";
                        // æ™ºèƒ½è°ƒæ•´æ–‡æœ¬æ¡†é«˜åº¦
                        smartResizeTextarea(outputText);
                        return;
                    }
                    
                    // å…ˆæ‰§è¡Œæ›¿æ¢
                    let processedText = text;
                    const enableReplace = document.getElementById('enable-replace').checked;
                    const findText = document.getElementById('find-text').value;
                    const replaceText = document.getElementById('replace-text').value;
                    
                    if (enableReplace && findText) {
                        // åˆ›å»ºå…¨å±€æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œæ›¿æ¢
                        const regex = new RegExp(findText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                        processedText = processedText.replace(regex, replaceText);
                    }
                    
                    // è·å–è‡ªå®šä¹‰æ–­å¥è¯
                    const enableCustomBreak = document.getElementById('enable-custom-break').checked;
                    const customBreakWords = enableCustomBreak && customBreakWordsInput.value.trim() ? 
                        customBreakWordsInput.value.split(',').map(word => word.trim()).filter(word => word) : 
                        [];
                    
                    // æ ¼å¼åŒ–æ–‡æœ¬
                    const result = formatText(processedText, width, mode, customBreakWords);
                    outputText.value = result;
                    
                    // æ™ºèƒ½è°ƒæ•´æ–‡æœ¬æ¡†é«˜åº¦
                    smartResizeTextarea(outputText);
                } catch (error) {
                    console.error('æ ¼å¼åŒ–æ–‡æœ¬æ—¶å‘ç”Ÿé”™è¯¯:', error);
                    outputText.value = "æ ¼å¼åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¾“å…¥å†…å®¹æˆ–åˆ·æ–°é¡µé¢é‡è¯•";
                    
                    // æ™ºèƒ½è°ƒæ•´æ–‡æœ¬æ¡†é«˜åº¦
                    smartResizeTextarea(outputText);
                }
            });
            
            // æ ¼å¼åŒ–å‡½æ•°
            function formatText(text, maxWidth = 80, mode = 'char', customBreakWords = []) {
                // é¢„å¤„ç†ï¼šä¿æŠ¤æˆå¯¹ç¬¦å·å†…çš„å†…å®¹
                const protectedSymbols = [];
                let processedText = text;
                
                // åªæœ‰åœ¨équotesæ¨¡å¼ä¸‹æ‰é¢„å¤„ç†æˆå¯¹ç¬¦å·ï¼ˆquotesæ¨¡å¼éœ€è¦ç‰¹æ®Šå¤„ç†å¼•å·ï¼‰
                if (mode !== 'quotes') {
                    // ä¿æŠ¤å„ç§æˆå¯¹ç¬¦å·å†…çš„å†…å®¹ï¼ˆä½¿ç”¨ç®€å•çš„ä¸€æ¬¡æ€§æ›¿æ¢ï¼‰
                    const protectSymbols = [
                        // ä¸­æ–‡ä¹¦åå·ï¼ˆä¼˜å…ˆå¤„ç†ï¼‰
                        { pattern: /ã€Š[^ã€Šã€‹]*ã€‹/g, type: 'bookTitle' },
                        // ä¸­æ–‡åŒå¼•å·
                        { pattern: /"[^"]*"/g, type: 'chineseQuote' },
                        // è‹±æ–‡åŒå¼•å·
                        { pattern: /"[^"]*"/g, type: 'englishQuote' },
                        // ä¸­æ–‡å•å¼•å·
                        { pattern: /'[^']*'/g, type: 'chineseSingleQuote' },
                        // è‹±æ–‡å•å¼•å·ï¼ˆä½†æ’é™¤æ’‡å·ï¼‰
                        { pattern: /(?<!\w)'[^']*'(?!\w)/g, type: 'englishSingleQuote' },
                        // ä¸­æ–‡æ‹¬å·
                        { pattern: /ï¼ˆ[^ï¼ˆï¼‰]*ï¼‰/g, type: 'chineseParen' },
                        // è‹±æ–‡æ‹¬å·
                        { pattern: /\([^()]*\)/g, type: 'englishParen' },
                        // ä¸­æ–‡æ–¹æ‹¬å·
                        { pattern: /ã€[^ã€ã€‘]*ã€‘/g, type: 'chineseBracket' },
                        // è‹±æ–‡æ–¹æ‹¬å·
                        { pattern: /\[[^\[\]]*\]/g, type: 'englishBracket' },
                        // èŠ±æ‹¬å·
                        { pattern: /\{[^{}]*\}/g, type: 'curlyBrace' }
                    ];
                    
                    // ä¿æŠ¤æˆå¯¹ç¬¦å·
                    for (const symbolDef of protectSymbols) {
                        processedText = processedText.replace(symbolDef.pattern, function(match) {
                            const placeholder = `__PROTECTED_${protectedSymbols.length}__`;
                            protectedSymbols.push(match);
                            return placeholder;
                        });
                    }
                }
                
                // æ³¨æ„ï¼šå¼•å·å·²ç»åœ¨æˆå¯¹ç¬¦å·ä¸­å¤„ç†è¿‡äº†ï¼Œè¿™é‡Œä¸éœ€è¦é¢å¤–å¤„ç†
                const quotedTexts = [];
                
                let result;
                
                if (mode === 'char') {
                    // æŒ‰å­—ç¬¦æ•°åˆ†æ®µ
                    const resultArray = [];
                    for (let i = 0; i < processedText.length; i += maxWidth) {
                        resultArray.push(processedText.substring(i, i + maxWidth));
                    }
                    result = resultArray.join('\n');
                    
                } else if (mode === 'word') {
                    // æŒ‰å•è¯åˆ†æ®µï¼Œé¿å…å•è¯è¢«æˆªæ–­
                    const words = processedText.split(/\s+/);
                    const lines = [];
                    let currentLine = [];
                    let currentLength = 0;
                    
                    for (const word of words) {
                        const wordLength = word.length;
                        const spaceLength = currentLength > 0 ? 1 : 0;
                        
                        if (currentLength + wordLength + spaceLength <= maxWidth) {
                            currentLine.push(word);
                            currentLength += wordLength + spaceLength;
                        } else {
                            lines.push(currentLine.join(' '));
                            currentLine = [word];
                            currentLength = wordLength;
                        }
                    }
                    
                    if (currentLine.length > 0) {
                        lines.push(currentLine.join(' '));
                    }
                    
                    result = lines.join('\n');
                    
                } else if (mode === 'sentence') {
                    // æŒ‰å¥å­åˆ†æ®µ
                    // ä¿®å¤ï¼šåŒæ—¶åŒ¹é…ä¸­è‹±æ–‡å¥å·ã€é—®å·ã€æ„Ÿå¹å·ï¼Œä¸”å…è®¸æ„Ÿå¹å·åæ— ç©ºæ ¼çš„æƒ…å†µ
                    const sentences = processedText.split(/(?<=[.!?ã€‚ï¼ï¼Ÿ])\s*(?=\S|$)/);
                    result = sentences.join('\n');
                    
                } else if (mode === 'punctuation') {
                    // æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µ - ä½¿ç”¨é€å­—ç¬¦æ‰«ææ–¹æ³•ï¼Œé¿å…splitå¯èƒ½å¯¼è‡´çš„å­—ç¬¦ä¸¢å¤±
                    
                    // ç¬¬1æ­¥ï¼šæŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µï¼ˆåº•å±‚é€»è¾‘ï¼Œä¼˜å…ˆçº§æœ€é«˜ï¼‰
                    // ä½¿ç”¨é€å­—ç¬¦æ‰«æçš„æ–¹æ³•ï¼Œç¡®ä¿ä¸ä¼šä¸¢å¤±ä»»ä½•å­—ç¬¦
                    const punctuationBasedSegments = [];
                    let currentSegment = '';
                    
                    // å®šä¹‰æ ‡ç‚¹ç¬¦å·é›†åˆ
                    const punctuationChars = new Set(['ï¼Œ', 'ã€‚', 'ï¼›', 'ï¼š', 'ï¼', 'ï¼Ÿ', 'ã€', ',', '.', ';', ':', '!', '?']);
                    
                    for (let i = 0; i < processedText.length; i++) {
                        const char = processedText[i];
                        currentSegment += char;
                        
                        // å¦‚æœé‡åˆ°æ ‡ç‚¹ç¬¦å·ï¼Œç»“æŸå½“å‰åˆ†æ®µ
                        if (punctuationChars.has(char)) {
                            if (currentSegment.length > 0) {
                                punctuationBasedSegments.push(currentSegment);
                            }
                            currentSegment = '';
                        }
                    }
                    
                    // å¤„ç†æœ€åä¸€ä¸ªåˆ†æ®µï¼ˆå¦‚æœæ²¡æœ‰ä»¥æ ‡ç‚¹ç¬¦å·ç»“å°¾ï¼‰
                    if (currentSegment.length > 0) {
                        punctuationBasedSegments.push(currentSegment);
                    }
                    
                    // ç¬¬2æ­¥ï¼šåœ¨æ ‡ç‚¹ç¬¦å·åˆ†æ®µåŸºç¡€ä¸Šï¼Œå¯¹è¶…è¿‡å­—æ•°çš„æ®µè½åº”ç”¨è‡ªå®šä¹‰æ–­å¥è¯
                    let intermediateSegments = [];
                    
                    for (const segment of punctuationBasedSegments) {
                        // å¦‚æœæœ‰è‡ªå®šä¹‰æ–­å¥è¯ï¼Œå…ˆåº”ç”¨è‡ªå®šä¹‰æ–­å¥è¯
                        if (customBreakWords.length > 0) {
                            let processedSegment = segment;
                            let hasCustomBreak = false;
                            
                            for (const word of customBreakWords) {
                                if (word) {
                                    const regex = new RegExp(`(\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b)`, 'g');
                                    const beforeReplace = processedSegment;
                                    processedSegment = processedSegment.replace(regex, '\n$1');
                                    if (processedSegment !== beforeReplace) {
                                        hasCustomBreak = true;
                                    }
                                }
                            }
                            
                            // å¦‚æœåº”ç”¨äº†è‡ªå®šä¹‰æ–­å¥è¯ï¼ŒæŒ‰æ¢è¡Œç¬¦åˆ†å‰²
                            if (hasCustomBreak) {
                                const customSplitSegments = processedSegment.split('\n');
                                for (const subSegment of customSplitSegments) {
                                    if (subSegment.length > 0) { // æ”¹ç”¨lengthæ£€æŸ¥
                                        intermediateSegments.push(subSegment);
                                    }
                                }
                            } else {
                                // æ²¡æœ‰åº”ç”¨è‡ªå®šä¹‰æ–­å¥è¯ï¼Œä¿æŒåŸæ ·
                                intermediateSegments.push(segment);
                            }
                        } else {
                            // æ²¡æœ‰è‡ªå®šä¹‰æ–­å¥è¯ï¼Œç›´æ¥æ·»åŠ 
                            intermediateSegments.push(segment);
                        }
                    }
                    
                    // ç¬¬3æ­¥ï¼šå¯¹æ‰€æœ‰æ®µè½è¿›è¡Œä¸­ä½æ•°åˆ†æ®µæ£€æŸ¥ï¼Œç¡®ä¿æ¯ä¸€è¡Œéƒ½ç¬¦åˆå®½åº¦è¦æ±‚
                    // é€’å½’ä¸­ä½æ•°åˆ†æ®µå‡½æ•°ï¼Œç¡®ä¿æ¯ä¸€è¡Œéƒ½ä¸¥æ ¼ç¬¦åˆå®½åº¦è¦æ±‚
                    function recursiveMidPointSplit(text) {
                        if (text.length <= maxWidth) {
                            return [text];
                        }
                        
                        // è®¡ç®—ä¸­ä½æ•°åˆ†å‰²ç‚¹
                        const midPoint = Math.floor(text.length / 2);
                        
                        // å¯»æ‰¾ä¸­ä½æ•°é™„è¿‘æœ€åˆé€‚çš„åˆ†å‰²ç‚¹ï¼ˆç©ºæ ¼ä½ç½®ï¼‰
                        let bestSplitIndex = midPoint;
                        
                        // åœ¨ä¸­ä½æ•°å‰å20%èŒƒå›´å†…å¯»æ‰¾ç©ºæ ¼
                        const searchRange = Math.floor(text.length * 0.2);
                        const searchStart = Math.max(0, midPoint - searchRange);
                        const searchEnd = Math.min(text.length - 1, midPoint + searchRange);
                        
                        // ä¼˜å…ˆåœ¨ä¸­ä½æ•°åé¢å¯»æ‰¾ç©ºæ ¼
                        for (let i = midPoint; i <= searchEnd; i++) {
                            if (text[i] === ' ') {
                                bestSplitIndex = i;
                                break;
                            }
                        }
                        
                        // å¦‚æœåé¢æ²¡æ‰¾åˆ°ï¼Œåœ¨å‰é¢å¯»æ‰¾ç©ºæ ¼
                        if (bestSplitIndex === midPoint && text[midPoint] !== ' ') {
                            for (let i = midPoint - 1; i >= searchStart; i--) {
                                if (text[i] === ' ') {
                                    bestSplitIndex = i;
                                    break;
                                }
                            }
                        }
                        
                        // è¿›è¡Œåˆ†å‰²
                        let firstPart, secondPart;
                        
                        if (text[bestSplitIndex] === ' ') {
                            // å¦‚æœåˆ†å‰²ç‚¹æ˜¯ç©ºæ ¼ï¼Œè·³è¿‡ç©ºæ ¼
                            firstPart = text.substring(0, bestSplitIndex).trim();
                            secondPart = text.substring(bestSplitIndex + 1).trim();
                        } else {
                            // å¦‚æœåˆ†å‰²ç‚¹ä¸æ˜¯ç©ºæ ¼ï¼ˆæ²¡æ‰¾åˆ°ç©ºæ ¼ï¼Œä½¿ç”¨ä¸­ä½æ•°åˆ†å‰²ï¼‰ï¼Œä¸è¦è·³è¿‡å­—ç¬¦
                            firstPart = text.substring(0, bestSplitIndex).trim();
                            secondPart = text.substring(bestSplitIndex).trim();
                        }
                        
                        // é€’å½’å¤„ç†æ¯ä¸€éƒ¨åˆ†ï¼Œç¡®ä¿éƒ½ç¬¦åˆå®½åº¦è¦æ±‚
                        const results = [];
                        if (firstPart) {
                            results.push(...recursiveMidPointSplit(firstPart));
                        }
                        if (secondPart) {
                            results.push(...recursiveMidPointSplit(secondPart));
                        }
                        
                        return results;
                    }
                    
                    // å¯¹æ‰€æœ‰ä¸­é—´æ®µè½è¿›è¡Œæœ€ç»ˆçš„å®½åº¦æ£€æŸ¥å’Œä¸­ä½æ•°åˆ†æ®µ
                    let finalSegments = [];
                    for (const segment of intermediateSegments) {
                        // åœ¨æ£€æŸ¥é•¿åº¦å‰å…ˆtrimï¼Œä½†ä¸åœ¨ä¸­é—´è¿‡ç¨‹ä¸­trim
                        const trimmedSegment = segment.trim();
                        if (trimmedSegment.length === 0) continue; // è·³è¿‡ç©ºæ®µè½
                        
                        if (trimmedSegment.length <= maxWidth) {
                            finalSegments.push(trimmedSegment);
                        } else {
                            // ä½¿ç”¨é€’å½’å‡½æ•°å¤„ç†è¶…é•¿æ®µè½
                            const splitResults = recursiveMidPointSplit(trimmedSegment);
                            finalSegments.push(...splitResults);
                        }
                    }
                    
                    result = finalSegments.join('\n');
                    
                } else if (mode === 'word_and_punctuation') {
                    // æŒ‰å•è¯å’Œæ ‡ç‚¹ç¬¦å·åˆ†æ®µ
                    // å…ˆæŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µï¼Œä½†æ’é™¤è¯ä¸­çš„æ’‡å·(apostrophe)ã€å¼•å·å’Œæˆå¯¹ç¬¦å·
                    // æ³¨æ„ï¼šç”±äºæˆå¯¹ç¬¦å·å·²ç»è¢«ä¿æŠ¤ï¼Œè¿™é‡Œåªå¤„ç†å•ç‹¬çš„æ ‡ç‚¹ç¬¦å·
                    let text = processedText.replace(/([,.;:!?ï¼Œã€‚ï¼›ï¼šï¼ï¼Ÿã€]|(?<!\w)'(?!\w)|(?<!\w)'(?!\w))/g, '$1\n');
                    
                    // åº”ç”¨è‡ªå®šä¹‰æ–­å¥è¯ - åªå¯¹è¶…è¿‡æœ€å¤§å®½åº¦çš„æ®µè½åº”ç”¨
                    if (customBreakWords.length > 0) {
                        const lines = text.split('\n');
                        const newLines = [];
                        
                        for (const line of lines) {
                            // åªæœ‰å½“æ®µè½é•¿åº¦è¶…è¿‡æœ€å¤§å®½åº¦æ—¶ï¼Œæ‰åº”ç”¨è‡ªå®šä¹‰æ–­å¥è¯
                            if (line.length > maxWidth) {
                                let processedLine = line;
                                // ä¸ºæ¯ä¸ªè‡ªå®šä¹‰æ–­å¥è¯åˆ›å»ºæ­£åˆ™è¡¨è¾¾å¼å¹¶åº”ç”¨
                                for (const word of customBreakWords) {
                                    if (word) {
                                        const regex = new RegExp(`(\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b)`, 'g');
                                        processedLine = processedLine.replace(regex, '\n$1');
                                    }
                                }
                                // å°†å¤„ç†åçš„è¡ŒæŒ‰æ–­å¥è¯æ‹†åˆ†å¹¶æ·»åŠ åˆ°ç»“æœä¸­
                                newLines.push(...processedLine.split('\n'));
                            } else {
                                newLines.push(line);
                            }
                        }
                        text = newLines.join('\n');
                    }
                    
                    const segments = text.split('\n');
                    const resultArray = [];
                    
                    // å¯¹æ¯ä¸ªåˆ†æ®µå†æŒ‰å•è¯åˆ†æ®µ
                    for (const segment of segments) {
                        if (!segment.trim()) continue;
                        
                        const words = segment.split(/\s+/);
                        const lines = [];
                        let currentLine = [];
                        let currentLength = 0;
                        
                        for (const word of words) {
                            const wordLength = word.length;
                            const spaceLength = currentLength > 0 ? 1 : 0;
                            
                            if (currentLength + wordLength + spaceLength <= maxWidth) {
                                currentLine.push(word);
                                currentLength += wordLength + spaceLength;
                            } else {
                                lines.push(currentLine.join(' '));
                                currentLine = [word];
                                currentLength = wordLength;
                            }
                        }
                        
                        if (currentLine.length > 0) {
                            lines.push(currentLine.join(' '));
                        }
                        
                        resultArray.push(lines.join('\n'));
                    }
                    
                    result = resultArray.join('\n');
                    
                } else if (mode === 'natural') {
                    // è‡ªç„¶è¯­è¨€åˆ†æ®µ - é‡å†™é€»è¾‘ï¼šå…ˆä¸¥æ ¼æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†æ®µï¼Œå†å¯¹è¶…è¿‡å­—æ•°çš„åˆ†æ®µè¿›è¡Œè‡ªç„¶è¯­è¨€å¤„ç†
                    
                    // ç¬¬ä¸€æ­¥ï¼šä¸¥æ ¼æŒ‰ç…§æ ‡ç‚¹ç¬¦å·è¿›è¡Œåˆ†æ®µï¼ˆåº•å±‚é€»è¾‘ï¼Œä¸å¯æ”¹åŠ¨ï¼‰
                    // åŒ¹é…ä¸­è‹±æ–‡å„ç§æ ‡ç‚¹ç¬¦å·ï¼Œä½†æ’é™¤è¯ä¸­çš„æ’‡å·ã€å¼•å·å’Œæˆå¯¹ç¬¦å·
                    // æ³¨æ„ï¼šç”±äºæˆå¯¹ç¬¦å·å·²ç»è¢«ä¿æŠ¤ï¼Œè¿™é‡Œåªå¤„ç†å•ç‹¬çš„æ ‡ç‚¹ç¬¦å·
                    let punctuationSegments = processedText.split(/([,.;:!?ï¼Œã€‚ï¼›ï¼šï¼ï¼Ÿã€]|(?<!\w)'(?!\w)|(?<!\w)'(?!\w))/);
                    
                    // æ¸…ç†å’Œé‡ç»„åˆ†æ®µï¼Œå°†æ ‡ç‚¹ç¬¦å·ä¸å‰é¢çš„æ–‡æœ¬åˆå¹¶
                    const cleanedSegments = [];
                    let currentSegment = '';
                    
                    for (let i = 0; i < punctuationSegments.length; i++) {
                        const part = punctuationSegments[i];
                        
                        // æ³¨æ„ï¼šä¸èƒ½ç®€å•è·³è¿‡ç©ºå­—ç¬¦ä¸²ï¼Œå› ä¸ºè¿™å¯èƒ½å¯¼è‡´å­—ç¬¦ä¸¢å¤±
                        if (part === undefined || part === null) continue;
                        
                        // å¦‚æœæ˜¯æ ‡ç‚¹ç¬¦å·ï¼Œä¸å‰é¢çš„å†…å®¹åˆå¹¶
                        if (/^[,.;:!?ï¼Œã€‚ï¼›ï¼šï¼ï¼Ÿã€'']$/.test(part)) {
                            currentSegment += part;
                            // æ ‡ç‚¹ç¬¦å·åç»“æŸå½“å‰åˆ†æ®µ
                            if (currentSegment.length > 0) { // æ”¹ç”¨lengthæ£€æŸ¥ï¼Œé¿å…trimä¸¢å¤±å­—ç¬¦
                                cleanedSegments.push(currentSegment);
                            }
                            currentSegment = '';
                        } else {
                            // å¦‚æœä¸æ˜¯æ ‡ç‚¹ç¬¦å·ï¼Œç´¯ç§¯åˆ°å½“å‰åˆ†æ®µï¼ˆåŒ…æ‹¬ç©ºå­—ç¬¦ä¸²ï¼Œé¿å…ä¸¢å¤±å­—ç¬¦ï¼‰
                            currentSegment += part;
                        }
                    }
                    
                    // å¤„ç†æœ€åä¸€ä¸ªåˆ†æ®µ
                    if (currentSegment.length > 0) { // æ”¹ç”¨lengthæ£€æŸ¥ï¼Œé¿å…trimä¸¢å¤±å­—ç¬¦
                        cleanedSegments.push(currentSegment);
                    }
                    
                    // ç¬¬äºŒæ­¥ï¼šåˆ¤æ–­æ¯ä¸ªåˆ†æ®µçš„å­—æ•°ï¼Œå¯¹è¶…è¿‡é™å®šå­—æ•°çš„åˆ†æ®µè¿›è¡Œè‡ªç„¶è¯­è¨€å¤„ç†
                    const finalSegments = [];
                    
                    for (const segment of cleanedSegments) {
                        // å¦‚æœåˆ†æ®µå­—æ•°æœªè¶…è¿‡é™å®šå­—æ•°ï¼Œç›´æ¥ä¿ç•™
                        if (segment.length <= maxWidth) {
                            finalSegments.push(segment);
                            continue;
                        }
                        
                        // å¦‚æœåˆ†æ®µå­—æ•°è¶…è¿‡äº†é™å®šå­—æ•°ï¼Œè¿›è¡Œè‡ªç„¶è¯­è¨€å¤„ç†
                        let processedSegment = segment;
                        
                        // åº”ç”¨è‡ªå®šä¹‰æ–­å¥è¯ï¼ˆå¦‚æœå¯ç”¨ä¸”æœ‰è®¾ç½®ï¼‰ - æ³¨æ„ï¼šåªåœ¨è¶…é•¿åˆ†æ®µä¸Šåº”ç”¨
                        if (customBreakWords.length > 0) {
                            for (const word of customBreakWords) {
                                if (word) {
                                    const regex = new RegExp(`(\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b)`, 'g');
                                    processedSegment = processedSegment.replace(regex, '\n$1');
                                }
                            }
                            
                            // å¦‚æœåº”ç”¨äº†è‡ªå®šä¹‰æ–­å¥è¯ï¼ŒæŒ‰æ¢è¡Œç¬¦åˆ†å‰²å¹¶æ£€æŸ¥æ¯ä¸ªå­æ®µ
                            const customSplitSegments = processedSegment.split('\n');
                            for (const subSegment of customSplitSegments) {
                                if (!subSegment.trim()) continue;
                                
                                if (subSegment.length <= maxWidth) {
                                    finalSegments.push(subSegment.trim());
                                } else {
                                    // å¦‚æœå­æ®µä»ç„¶è¶…é•¿ï¼Œç”¨å•è¯åˆ†æ®µ
                                    const words = subSegment.trim().split(/\s+/);
                                    let currentLine = [];
                                    let currentLength = 0;
                                    
                                    for (const word of words) {
                                        const wordLength = word.length;
                                        const spaceLength = currentLength > 0 ? 1 : 0;
                                        
                                        if (currentLength + wordLength + spaceLength <= maxWidth) {
                                            currentLine.push(word);
                                            currentLength += wordLength + spaceLength;
                                        } else {
                                            if (currentLine.length > 0) {
                                                finalSegments.push(currentLine.join(' '));
                                            }
                                            currentLine = [word];
                                            currentLength = wordLength;
                                        }
                                    }
                                    
                                    if (currentLine.length > 0) {
                                        finalSegments.push(currentLine.join(' '));
                                    }
                                }
                            }
                        } else {
                                                         // æ²¡æœ‰è‡ªå®šä¹‰æ–­å¥è¯ï¼Œä½¿ç”¨è‡ªç„¶è¯­è¨€è¿æ¥è¯è¿›è¡Œåˆ†æ®µ
                            const naturalBreakPoints = [
                                // è‹±æ–‡å¸¸è§çš„è¿æ¥è¯å’ŒçŸ­è¯­
                                /\s+(and|but|however|therefore|moreover|furthermore|consequently|nevertheless)\s+/gi,
                                /\s+(in\s+addition|on\s+the\s+other\s+hand|for\s+example|in\s+fact|as\s+a\s+result)\s+/gi,
                                /\s+(in\s+contrast|instead|meanwhile|whereas|though|although|unless|since|while|because|yet|still)\s+/gi,
                                
                                // ä¸­æ–‡å¸¸è§è¿æ¥è¯å’ŒçŸ­è¯­
                                /(ç„¶è€Œ|ä½†æ˜¯|ä¸è¿‡|å› æ­¤|æ‰€ä»¥|å› è€Œ|æ­¤å¤–|å¦å¤–|è€Œä¸”|å†µä¸”|ä¸ä»…å¦‚æ­¤|ä¸æ­¤åŒæ—¶|ç›¸å|æ€»ä¹‹|æ€»è€Œè¨€ä¹‹|å°½ç®¡å¦‚æ­¤)/g
                            ];
                            
                            let subSegments = [processedSegment];
                            
                            // åœ¨è‡ªç„¶åœé¡¿å¤„è¿›è¡Œåˆ†æ®µ - åªæœ‰åœ¨åˆ†æ®µåä»éœ€è¦è¿›ä¸€æ­¥åˆ†æ®µæ—¶æ‰è¿›è¡Œ
                            for (const pattern of naturalBreakPoints) {
                                let newSubSegments = [];
                                
                                for (const subSegment of subSegments) {
                                    if (subSegment.length <= maxWidth) {
                                        newSubSegments.push(subSegment);
                                        continue;
                                    }
                                    
                                    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ‰¾åˆ°æ‰€æœ‰åŒ¹é…çš„è¿æ¥è¯ä½ç½®
                                    const matches = [];
                                    let match;
                                    const regex = new RegExp(pattern.source, pattern.flags);
                                    
                                    while ((match = regex.exec(subSegment)) !== null) {
                                        matches.push({
                                            index: match.index,
                                            length: match[0].length,
                                            text: match[0]
                                        });
                                        // é˜²æ­¢æ— é™å¾ªç¯
                                        if (!pattern.global) break;
                                    }
                                    
                                    if (matches.length > 0) {
                                        let bestSplit = null;
                                        
                                        // æ‰¾åˆ°æœ€ä½³çš„åˆ†å‰²ç‚¹ï¼šåˆ†å‰²åä¸¤éƒ¨åˆ†éƒ½å°½å¯èƒ½æ¥è¿‘ä½†ä¸è¶…è¿‡maxWidth
                                        for (const matchInfo of matches) {
                                            const beforePart = subSegment.substring(0, matchInfo.index).trim();
                                            const afterStart = matchInfo.index + matchInfo.length;
                                            const afterPart = subSegment.substring(afterStart).trim();
                                            const afterWithConnector = matchInfo.text.trim() + ' ' + afterPart;
                                            
                                            // æ£€æŸ¥åˆ†å‰²æ˜¯å¦æœ‰æ„ä¹‰ï¼šä¸¤éƒ¨åˆ†éƒ½åº”è¯¥æ¯”åŸæ–‡æœ¬çŸ­ï¼Œå¹¶ä¸”è‡³å°‘ä¸€éƒ¨åˆ†è¶…è¿‡äº†maxWidth
                                            if (beforePart && afterPart && 
                                                (beforePart.length > maxWidth || afterWithConnector.length > maxWidth)) {
                                                
                                                // å¦‚æœå‰åŠéƒ¨åˆ†ä¸è¶…è¿‡maxWidthï¼Œè€ŒååŠéƒ¨åˆ†è¶…è¿‡ï¼Œè¿™æ˜¯ä¸€ä¸ªå¥½çš„åˆ†å‰²ç‚¹
                                                if (beforePart.length <= maxWidth && afterWithConnector.length > maxWidth) {
                                                    bestSplit = {
                                                        before: beforePart,
                                                        after: afterWithConnector
                                                    };
                                                    break;
                                                }
                                                // å¦‚æœä¸¤éƒ¨åˆ†éƒ½è¶…è¿‡maxWidthï¼Œä¹Ÿå¯ä»¥åˆ†å‰²ï¼ˆè‡³å°‘å‡å°‘äº†ä¸€éƒ¨åˆ†çš„é•¿åº¦ï¼‰
                                                else if (beforePart.length > maxWidth && afterWithConnector.length > maxWidth) {
                                                    bestSplit = {
                                                        before: beforePart,
                                                        after: afterWithConnector
                                                    };
                                                    break;
                                                }
                                            }
                                        }
                                        
                                        if (bestSplit) {
                                            newSubSegments.push(bestSplit.before);
                                            newSubSegments.push(bestSplit.after);
                                        } else {
                                            // æ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„åˆ†å‰²ç‚¹ï¼Œä¿æŒåŸæ ·
                                            newSubSegments.push(subSegment);
                                        }
                                    } else {
                                        newSubSegments.push(subSegment);
                                    }
                                }
                                
                                subSegments = newSubSegments.filter(s => s && s.trim());
                            }
                            
                            // å¤„ç†ç»“æœï¼Œåªå¯¹æ˜¾è‘—è¶…é•¿çš„å­æ®µè¿›è¡Œå•è¯åˆ†æ®µ
                            for (const subSegment of subSegments) {
                                if (!subSegment.trim()) continue;
                                
                                // ç»™äºˆä¸€å®šçš„å®½å®¹åº¦ï¼šå¦‚æœè¶…å‡ºä¸å¤šï¼ˆæ¯”å¦‚ä¸è¶…è¿‡maxWidthçš„1.2å€ï¼‰ï¼Œå°±ä¿æŒåŸæ ·
                                if (subSegment.length <= maxWidth * 1.2) {
                                    finalSegments.push(subSegment.trim());
                                } else {
                                    // åªæœ‰æ˜¾è‘—è¶…é•¿çš„å­æ®µæ‰ç”¨å•è¯åˆ†æ®µå¤„ç†
                                    const words = subSegment.trim().split(/\s+/);
                                    let currentLine = [];
                                    let currentLength = 0;
                                    
                                    for (const word of words) {
                                        const wordLength = word.length;
                                        const spaceLength = currentLength > 0 ? 1 : 0;
                                        
                                        if (currentLength + wordLength + spaceLength <= maxWidth) {
                                            currentLine.push(word);
                                            currentLength += wordLength + spaceLength;
                                        } else {
                                            if (currentLine.length > 0) {
                                                finalSegments.push(currentLine.join(' '));
                                            }
                                            currentLine = [word];
                                            currentLength = wordLength;
                                        }
                                    }
                                    
                                    if (currentLine.length > 0) {
                                        finalSegments.push(currentLine.join(' '));
                                    }
                                }
                            }
                        }
                    }
                    
                    result = finalSegments.join('\n');
                    
                } else if (mode === 'quotes') {
                    // æŒ‰å¼•å·æ–­å¥ - åœ¨æ¯ä¸ªåŒå¼•å·ç»“æŸåæ–­å¥
                    // æ³¨æ„ï¼šåœ¨quotesæ¨¡å¼ä¸‹ï¼Œæˆ‘ä»¬ç›´æ¥ä½¿ç”¨åŸå§‹æ–‡æœ¬ï¼Œå› ä¸ºè¿™ä¸ªæ¨¡å¼ä¸“é—¨å¤„ç†å¼•å·
                    
                    // åœ¨å¼•å·åæ–­å¥
                    result = text.replace(/"([^"]*)"/g, '"$1"\n');
                    
                    // å¤„ç†è¿‡é•¿çš„è¡Œï¼ˆä¸åœ¨å¼•å·ä¸­çš„æ–‡æœ¬ï¼‰
                    if (result.length > 0) {
                        const lines = result.split('\n');
                        const processedLines = [];
                        
                        for (const line of lines) {
                            // è·³è¿‡ç©ºè¡Œ
                            if (!line.trim()) {
                                continue;
                            }
                            
                            // æ£€æŸ¥è¡Œæ˜¯å¦å¤ªé•¿ï¼Œå¦‚æœæ˜¯åˆ™è¿›ä¸€æ­¥åˆ†æ®µ
                            if (line.length > maxWidth) {
                                // æŒ‰å•è¯åˆ†æ®µ
                                const words = line.split(/\s+/);
                                let currentLine = [];
                                let currentLength = 0;
                                
                                for (const word of words) {
                                    const wordLength = word.length;
                                    const spaceLength = currentLength > 0 ? 1 : 0;
                                    
                                    if (currentLength + wordLength + spaceLength <= maxWidth) {
                                        currentLine.push(word);
                                        currentLength += wordLength + spaceLength;
                                    } else {
                                        processedLines.push(currentLine.join(' '));
                                        currentLine = [word];
                                        currentLength = wordLength;
                                    }
                                }
                                
                                if (currentLine.length > 0) {
                                    processedLines.push(currentLine.join(' '));
                                }
                            } else {
                                processedLines.push(line);
                            }
                        }
                        
                        result = processedLines.join('\n');
                    }
                    
                    // ç›´æ¥è¿”å›ç»“æœï¼Œä¸éœ€è¦æ¢å¤å¼•å·å†…å®¹
                    return result;
                    
                } else {
                    return "é”™è¯¯: æ¨¡å¼å¿…é¡»æ˜¯ 'char', 'word', 'sentence', 'punctuation', 'word_and_punctuation', 'natural' æˆ– 'quotes'";
                }
                
                // æ¢å¤ä¿æŠ¤çš„æˆå¯¹ç¬¦å·å†…å®¹ï¼ˆä»…é’ˆå¯¹équotesæ¨¡å¼ï¼‰
                if (mode !== 'quotes') {
                    // æŒ‰å€’åºæ¢å¤ä¿æŠ¤çš„ç¬¦å·ï¼Œé¿å…åµŒå¥—æ›¿æ¢é—®é¢˜
                    for (let i = protectedSymbols.length - 1; i >= 0; i--) {
                        const placeholder = `__PROTECTED_${i}__`;
                        const originalContent = protectedSymbols[i];
                        // ä½¿ç”¨ç®€å•çš„å­—ç¬¦ä¸²æ›¿æ¢
                        result = result.split(placeholder).join(originalContent);
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æœªæ¢å¤çš„å ä½ç¬¦ï¼ˆè°ƒè¯•ç”¨ï¼‰
                    if (result.includes('__PROTECTED_')) {
                        console.warn('å‘ç°æœªæ¢å¤çš„ä¿æŠ¤ç¬¦å·å ä½ç¬¦:', result.match(/__PROTECTED_\d+__/g));
                    }
                }
                
                return result;
            }
            
            // åˆå§‹æ ¼å¼åŒ–ä¸€æ¬¡
            formatBtn.click();
        });
    </script>
</body>
</html> 